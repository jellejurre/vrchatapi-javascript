// This file is auto-generated by @hey-api/openapi-ts

/**
 * Status object representing if a queried user by username or userId exists or not. This model is primarily used by the `/auth/exists` endpoint, which in turn is used during registration. Please see the documentation on that endpoint for more information on usage.
 */
export type UserExists = {
    /**
     * Status if a user exist with that username or userId.
     */
    userExists: boolean;
};

export type Response = {
    message?: string;
    status_code: number;
};

export type Error = {
    error?: Response;
};

export type AccountDeletionLog = {
    /**
     * Typically "Deletion requested" or "Deletion canceled". Other messages like "Deletion completed" may exist, but are these are not possible to see as a regular user.
     */
    message?: string;
    /**
     * When the deletion is scheduled to happen, standard is 14 days after the request.
     */
    deletionScheduled?: string | null;
    /**
     * Date and time of the deletion request.
     */
    dateTime?: string;
};

/**
 * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
 */
export type UserID = string;

export type BadgeID = string;

export type Badge = {
    /**
     * only present in CurrentUser badges
     */
    assignedAt?: string | null;
    badgeDescription: string;
    badgeId: BadgeID;
    /**
     * direct url to image
     */
    badgeImageUrl: string;
    badgeName: string;
    /**
     * only present in CurrentUser badges
     */
    hidden?: boolean | null;
    showcased: boolean;
    /**
     * only present in CurrentUser badges
     */
    updatedAt?: string | null;
};

export type AvatarID = string;

/**
 * When profilePicOverride is not empty, use it instead.
 */
export type CurrentAvatarImageUrl = string;

/**
 * When profilePicOverride is not empty, use it instead.
 */
export type CurrentAvatarThumbnailImageUrl = string;

/**
 * Tags are a way to grant various access, assign restrictions or other kinds of metadata to various to objects such as worlds, users and avatars.
 *
 * System tags starting with `system_` are granted automatically by the system, while admin tags with `admin_` are granted manually. More prefixes such as `language_ ` (to indicate that a player can speak the tagged language), and `author_tag_` (provided by a world author for search and sorting) exist as well.
 */
export type Tag = string;

/**
 * "none" User is a normal user
 * "trusted" Unknown
 * "internal" Is a VRChat Developer
 * "moderator" Is a VRChat Moderator
 *
 * Staff can hide their developerType at will.
 */
export type DeveloperType = 'none' | 'trusted' | 'internal' | 'moderator';

/**
 * WorldID be "offline" on User profiles if you are not friends with that user.
 */
export type WorldID = string;

/**
 * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
 */
export type Platform = string;

export type PastDisplayName = {
    displayName: string;
    updated_at: string;
};

export type GroupID = string;

export type CurrentUserPresence = {
    avatarThumbnail?: string | null;
    displayName?: string;
    groups?: Array<GroupID> | null;
    id?: UserID;
    instance?: string | null;
    /**
     * either an InstanceType or an empty string
     */
    instanceType?: string | null;
    isRejoining?: string | null;
    /**
     * either a Platform or an empty string
     */
    platform?: string | null;
    profilePicOverride?: string | null;
    /**
     * either a UserStatus or empty string
     */
    status?: string | null;
    travelingToInstance?: string | null;
    travelingToWorld?: WorldID | null;
    world?: WorldID | null;
};

/**
 * * "online" User is online in VRChat
 * * "active" User is online, but not in VRChat
 * * "offline" User is offline
 *
 * Always offline when returned through `getCurrentUser` (/auth/user).
 */
export type UserState = 'offline' | 'active' | 'online';

/**
 * Defines the User's current status, for example "ask me", "join me" or "offline. This status is a combined indicator of their online activity and privacy preference.
 */
export type UserStatus = 'active' | 'join me' | 'ask me' | 'busy' | 'offline';

export type CurrentUser = {
    acceptedTOSVersion: number;
    acceptedPrivacyVersion?: number;
    accountDeletionDate?: string | null;
    /**
     *
     */
    accountDeletionLog?: Array<AccountDeletionLog> | null;
    /**
     *
     */
    activeFriends?: Array<UserID>;
    allowAvatarCopying: boolean;
    /**
     *
     */
    badges?: Array<Badge>;
    bio: string;
    /**
     *
     */
    bioLinks: Array<(string)>;
    currentAvatar: AvatarID;
    currentAvatarAssetUrl: string;
    currentAvatarImageUrl: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags: Array<Tag>;
    date_joined: string;
    developerType: DeveloperType;
    displayName: string;
    emailVerified: boolean;
    fallbackAvatar?: AvatarID;
    /**
     * Always empty array.
     * @deprecated
     */
    friendGroupNames: Array<(string)>;
    friendKey: string;
    friends: Array<UserID>;
    hasBirthday: boolean;
    hideContentFilterSettings?: boolean;
    userLanguage?: string | null;
    userLanguageCode?: string | null;
    hasEmail: boolean;
    hasLoggedInFromClient: boolean;
    hasPendingEmail: boolean;
    homeLocation: WorldID;
    id: UserID;
    isFriend: boolean;
    last_activity?: string;
    last_login: string;
    last_mobile: string | null;
    last_platform: Platform;
    obfuscatedEmail: string;
    obfuscatedPendingEmail: string;
    oculusId: string;
    googleId?: string;
    googleDetails?: {
        [key: string]: unknown;
    };
    picoId?: string;
    viveId?: string;
    offlineFriends?: Array<UserID>;
    onlineFriends?: Array<UserID>;
    /**
     *
     */
    pastDisplayNames: Array<PastDisplayName>;
    presence?: CurrentUserPresence;
    profilePicOverride: string;
    pronouns: string;
    state: UserState;
    status: UserStatus;
    statusDescription: string;
    statusFirstTime: boolean;
    statusHistory: Array<(string)>;
    steamDetails: {
        [key: string]: unknown;
    };
    steamId: string;
    tags: Array<Tag>;
    twoFactorAuthEnabled: boolean;
    twoFactorAuthEnabledDate?: string | null;
    unsubscribe: boolean;
    updated_at?: string;
    userIcon: string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    username?: string;
};

export type TwoFactorAuthCode = {
    code: string;
};

export type Verify2FAResult = {
    verified: boolean;
};

export type TwoFactorEmailCode = {
    code: string;
};

export type Verify2FAEmailCodeResult = {
    verified: boolean;
};

export type VerifyAuthTokenResult = {
    ok: boolean;
    token: string;
};

export type Success = {
    success?: Response;
};

export type ReleaseStatus = 'public' | 'private' | 'hidden' | 'all';

export type UnityPackageID = string;

export type UnityPackage = {
    id: UnityPackageID;
    assetUrl?: string | null;
    assetUrlObject?: {
        [key: string]: unknown;
    };
    assetVersion: number;
    created_at?: string;
    platform: Platform;
    pluginUrl?: string;
    pluginUrlObject?: {
        [key: string]: unknown;
    };
    unitySortNumber?: number;
    unityVersion: string;
    impostorUrl?: string | null;
    scanStatus?: string;
    variant?: string;
};

export type Avatar = {
    /**
     * Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`.
     */
    assetUrl?: string;
    /**
     * Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`.
     * **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
     */
    assetUrlObject?: {
        [key: string]: unknown;
    };
    authorId: UserID;
    authorName: string;
    created_at: string;
    description: string;
    featured: boolean;
    id: AvatarID;
    imageUrl: string;
    name: string;
    releaseStatus: ReleaseStatus;
    /**
     *
     */
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    unityPackageUrl: string;
    /**
     * **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
     * @deprecated
     */
    unityPackageUrlObject: {
        unityPackageUrl?: string;
    };
    unityPackages: Array<UnityPackage>;
    updated_at: string;
    version: number;
};

export type SortOption = 'popularity' | 'heat' | 'trust' | 'shuffle' | 'random' | 'favorites' | 'reportScore' | 'reportCount' | 'publicationDate' | 'labsPublicationDate' | 'created' | '_created_at' | 'updated' | '_updated_at' | 'order' | 'relevance' | 'magic' | 'name';

export type OrderOption = 'ascending' | 'descending';

export type CreateAvatarRequest = {
    assetUrl?: string;
    id?: AvatarID;
    name: string;
    description?: string;
    /**
     *
     */
    tags?: Array<Tag>;
    imageUrl: string;
    releaseStatus?: ReleaseStatus;
    version?: number;
    unityPackageUrl?: string;
    unityVersion?: string;
};

export type UpdateAvatarRequest = {
    assetUrl?: string;
    id?: AvatarID;
    name?: string;
    description?: string;
    /**
     *
     */
    tags?: Array<Tag>;
    imageUrl?: string;
    releaseStatus?: ReleaseStatus;
    version?: number;
    unityPackageUrl?: string;
    unityVersion?: string;
};

export type TransactionID = string;

export type TransactionStatus = 'active' | 'failed' | 'expired' | 'chargeback';

export type SubscriptionPeriod = 'hour' | 'day' | 'week' | 'month' | 'year';

export type Subscription = {
    id: string;
    steamItemId: string;
    oculusSku?: string;
    googleProductId?: string;
    googlePlanId?: string;
    picoSku?: string;
    amount: number;
    description: string;
    period: SubscriptionPeriod;
    tier: number;
};

export type TransactionSteamWalletInfo = {
    state: string;
    country: string;
    currency: string;
    status: string;
};

export type TransactionSteamInfo = {
    walletInfo: TransactionSteamWalletInfo;
    /**
     * Steam User ID
     */
    steamId: string;
    /**
     * Steam Order ID
     */
    orderId: string;
    /**
     * Empty
     */
    steamUrl: string;
    /**
     * Steam Transaction ID, NOT the same as VRChat TransactionID
     */
    transId: string;
};

export type TransactionAgreement = {
    agreementId: string;
    itemId: number;
    /**
     * This is NOT TransactionStatus, but whatever Steam return.
     */
    status: string;
    period: string;
    frequency: number;
    billingType: string;
    startDate: string;
    endDate: string;
    recurringAmt: number;
    currency: string;
    timeCreated: string;
    nextPayment: string;
    lastPayment: string;
    lastAmount: number;
    lastAmountVat: number;
    outstanding: number;
    failedAttempts: number;
};

export type Transaction = {
    id: TransactionID;
    userId?: UserID;
    userDisplayName?: string;
    status: TransactionStatus;
    subscription: Subscription;
    sandbox: boolean;
    created_at: string;
    updated_at: string;
    steam?: TransactionSteamInfo;
    agreement?: TransactionAgreement;
    error: string;
    isGift?: boolean;
    isTokens?: boolean;
};

export type LicenseGroupID = string;

export type UserSubscription = {
    id: string;
    transactionId: TransactionID;
    /**
     * Which "Store" it came from. Right now only Stores are "Steam" and "Admin".
     */
    store: string;
    steamItemId?: string;
    amount: number;
    description: string;
    period: SubscriptionPeriod;
    tier: number;
    active: boolean;
    status: TransactionStatus;
    expires: string;
    created_at: string;
    updated_at: string;
    licenseGroups: Array<LicenseGroupID>;
    isGift: boolean;
};

export type LicenseType = 'avatar' | 'licenseGroup' | 'permission' | 'product';

export type LicenseAction = 'wear' | 'have';

export type License = {
    /**
     * Either a AvatarID, LicenseGroupID, PermissionID or ProductID. This depends on the `forType` field.
     */
    forId: string;
    forType: LicenseType;
    forName: string;
    forAction: LicenseAction;
};

export type LicenseGroup = {
    id: LicenseGroupID;
    name: string;
    description: string;
    licenses: Array<License>;
};

export type FavoriteID = string;

export type FavoriteType = 'world' | 'friend' | 'avatar';

export type Favorite = {
    /**
     * MUST be either AvatarID, UserID or WorldID.
     */
    favoriteId: string;
    id: FavoriteID;
    /**
     *
     */
    tags: Array<Tag>;
    type: FavoriteType;
};

export type AddFavoriteRequest = {
    type: FavoriteType;
    /**
     * Must be either AvatarID, WorldID or UserID.
     */
    favoriteId: string;
    /**
     * Tags indicate which group this favorite belongs to. Adding multiple groups makes it show up in all. Removing it from one in that case removes it from all.
     */
    tags: Array<Tag>;
};

export type FavoriteGroupID = string;

export type FavoriteGroupVisibility = 'private' | 'friends' | 'public';

export type FavoriteGroup = {
    displayName: string;
    id: FavoriteGroupID;
    name: string;
    ownerDisplayName: string;
    ownerId: UserID;
    /**
     *
     */
    tags: Array<Tag>;
    type: FavoriteType;
    visibility: FavoriteGroupVisibility;
};

export type UpdateFavoriteGroupRequest = {
    displayName?: string;
    visibility?: FavoriteGroupVisibility;
    /**
     * Tags on FavoriteGroups are believed to do nothing.
     */
    tags?: Array<Tag>;
};

export type FileID = string;

export type MIMEType = 'image/jpeg' | 'image/jpg' | 'image/png' | 'image/webp' | 'image/gif' | 'image/bmp' | 'image/svg＋xml' | 'image/tiff' | 'application/x-avatar' | 'application/x-world' | 'application/gzip' | 'application/x-rsync-signature' | 'application/x-rsync-delta' | 'application/octet-stream';

export type FileStatus = 'waiting' | 'complete' | 'none' | 'queued';

export type FileData = {
    category: 'multipart' | 'queued' | 'simple';
    fileName: string;
    md5: string;
    sizeInBytes: number;
    status: FileStatus;
    uploadId: string;
    url: string;
};

export type category = 'multipart' | 'queued' | 'simple';

export type FileVersion = {
    created_at: string;
    /**
     * Usually only present if `true`
     */
    deleted?: boolean;
    delta?: FileData;
    file?: FileData;
    signature?: FileData;
    status: FileStatus;
    /**
     * Incremental version counter, can only be increased.
     */
    version: number;
};

export type File = {
    extension: string;
    id: FileID;
    mimeType: MIMEType;
    name: string;
    ownerId: UserID;
    /**
     *
     */
    tags: Array<Tag>;
    /**
     *
     */
    versions: Array<FileVersion>;
};

export type CreateFileRequest = {
    name: string;
    mimeType: MIMEType;
    extension: string;
    /**
     *
     */
    tags?: Array<Tag>;
};

export type CreateFileVersionRequest = {
    signatureMd5: string;
    signatureSizeInBytes: number;
    fileMd5?: string;
    fileSizeInBytes?: number;
};

export type FinishFileDataUploadRequest = {
    /**
     * Array of ETags uploaded.
     */
    etags?: Array<(string)>;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @deprecated
     */
    nextPartNumber: string;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @deprecated
     */
    maxParts: string;
};

export type FileUploadURL = {
    url: string;
};

export type FileVersionUploadStatus = {
    uploadId: string;
    fileName: string;
    nextPartNumber: number;
    maxParts: number;
    parts: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Unknown
     */
    etags: Array<{
        [key: string]: unknown;
    }>;
};

export type LimitedUser = {
    bio?: string;
    /**
     *
     */
    bioLinks?: Array<(string)>;
    currentAvatarImageUrl?: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl?: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags?: Array<Tag>;
    developerType: DeveloperType;
    displayName: string;
    fallbackAvatar?: AvatarID;
    id: UserID;
    isFriend: boolean;
    last_platform: Platform;
    profilePicOverride?: string;
    pronouns?: string;
    status: UserStatus;
    statusDescription: string;
    /**
     * <- Always empty.
     */
    tags: Array<Tag>;
    userIcon?: string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    username?: string;
    location?: string;
    friendKey?: string;
};

export type NotificationType = 'friendRequest' | 'invite' | 'inviteResponse' | 'message' | 'requestInvite' | 'requestInviteResponse' | 'votetokick';

export type Notification = {
    created_at: string;
    /**
     * **NOTICE:** This is not a JSON object when received from the REST API, but it is when received from the Websocket API. When received from the REST API, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
     */
    details: string;
    id: string;
    message: string;
    /**
     * Not included in notification objects received from the Websocket API
     */
    seen?: boolean;
    /**
     * Not included in notification objects received from the REST API
     */
    receiverUserId?: UserID;
    senderUserId: UserID;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    senderUsername?: string;
    type: NotificationType;
};

export type FriendStatus = {
    incomingRequest: boolean;
    isFriend: boolean;
    outgoingRequest: boolean;
};

export type GroupShortCode = string;

export type GroupDiscriminator = string;

export type GroupMemberStatus = 'inactive' | 'member' | 'requested' | 'invited' | 'banned';

export type GroupGalleryID = string;

export type GroupRoleID = string;

export type GroupGallery = {
    id?: GroupGalleryID;
    /**
     * Name of the gallery.
     */
    name?: string;
    /**
     * Description of the gallery.
     */
    description?: string;
    /**
     * Whether the gallery is members only.
     */
    membersOnly?: boolean;
    /**
     *
     */
    roleIdsToView?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToSubmit?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToAutoApprove?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToManage?: Array<GroupRoleID> | null;
    createdAt?: string;
    updatedAt?: string;
};

export type LimitedGroup = {
    id?: GroupID;
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconUrl?: string | null;
    bannerUrl?: string | null;
    ownerId?: UserID;
    rules?: string | null;
    iconId?: string | null;
    bannerId?: string | null;
    memberCount?: number;
    /**
     *
     */
    tags?: Array<Tag>;
    createdAt?: string;
    membershipStatus?: GroupMemberStatus;
    isSearchable?: boolean;
    /**
     *
     */
    galleries?: Array<GroupGallery>;
};

export type GroupJoinState = 'closed' | 'invite' | 'request' | 'open';

export type GroupPrivacy = 'default' | 'private';

export type GroupRoleTemplate = 'default' | 'managedFree' | 'managedInvite' | 'managedRequest';

export type CreateGroupRequest = {
    name: string;
    shortCode: string;
    description?: string;
    joinState?: GroupJoinState;
    iconId?: string | null;
    bannerId?: string | null;
    privacy?: GroupPrivacy;
    roleTemplate: GroupRoleTemplate;
};

export type GroupMemberID = string;

export type GroupMyMember = {
    id?: GroupMemberID;
    groupId?: GroupID;
    userId?: UserID;
    roleIds?: Array<GroupRoleID>;
    managerNotes?: string;
    membershipStatus?: string;
    isSubscribedToAnnouncements?: boolean;
    visibility?: string;
    isRepresenting?: boolean;
    joinedAt?: string;
    bannedAt?: string | null;
    has2FA?: boolean;
    permissions?: Array<(string)>;
};

export type GroupRole = {
    id?: GroupRoleID;
    groupId?: GroupID;
    name?: string;
    description?: string;
    isSelfAssignable?: boolean;
    permissions?: Array<(string)>;
    isManagementRole?: boolean;
    requiresTwoFactor?: boolean;
    requiresPurchase?: boolean;
    order?: number;
    createdAt?: string;
    updatedAt?: string;
};

export type Group = {
    id?: GroupID;
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconUrl?: string | null;
    bannerUrl?: string | null;
    privacy?: GroupPrivacy;
    ownerId?: UserID;
    rules?: string | null;
    links?: Array<(string)>;
    languages?: Array<(string)>;
    iconId?: string | null;
    bannerId?: string | null;
    memberCount?: number;
    memberCountSyncedAt?: string;
    isVerified?: boolean;
    joinState?: GroupJoinState;
    /**
     *
     */
    tags?: Array<Tag>;
    /**
     *
     */
    galleries?: Array<GroupGallery>;
    createdAt?: string;
    onlineMemberCount?: number;
    membershipStatus?: GroupMemberStatus;
    myMember?: GroupMyMember | null;
    /**
     * Only returned if ?includeRoles=true is specified.
     */
    roles?: Array<GroupRole> | null;
};

export type UpdateGroupRequest = {
    name?: string;
    shortCode?: string;
    description?: string;
    joinState?: GroupJoinState;
    iconId?: string | null;
    bannerId?: string | null;
    /**
     * 3 letter language code
     */
    languages?: Array<(string)>;
    links?: Array<(string)>;
    rules?: string;
    /**
     *
     */
    tags?: Array<Tag>;
};

export type GroupAnnouncementID = string;

export type GroupAnnouncement = {
    id?: GroupAnnouncementID | null;
    groupId?: GroupID | null;
    authorId?: UserID | null;
    title?: string | null;
    text?: string | null;
    imageId?: FileID | null;
    imageUrl?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
};

export type CreateGroupAnnouncementRequest = {
    /**
     * Announcement title
     */
    title: string;
    /**
     * Announcement text
     */
    text?: string;
    imageId?: FileID;
    /**
     * Send notification to group members.
     */
    sendNotification?: boolean;
};

export type GroupAuditLogID = string;

export type GroupAuditLogEntry = {
    id?: GroupAuditLogID;
    created_at?: string;
    groupId?: GroupID;
    actorId?: UserID;
    actorDisplayName?: string;
    /**
     * Typically GroupID or GroupRoleID, but could be other types of IDs.
     */
    targetId?: string;
    /**
     * The type of event that occurred. This is a string that is prefixed with the type of object that the event occurred on. For example, a group role update event would be prefixed with `group.role`.
     */
    eventType?: string;
    /**
     * A human-readable description of the event.
     */
    description?: string;
    /**
     * The data associated with the event. The format of this data is dependent on the event type.
     */
    data?: {
        [key: string]: unknown;
    };
};

export type PaginatedGroupAuditLogEntryList = {
    /**
     *
     */
    results?: Array<GroupAuditLogEntry>;
    /**
     * The total number of results that the query would return if there were no pagination.
     */
    totalCount?: number;
    /**
     * Whether there are more results after this page.
     */
    hasNext?: boolean;
};

/**
 * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
 */
export type GroupMemberLimitedUser = {
    id?: UserID;
    displayName?: string;
    thumbnailUrl?: string | null;
    iconUrl?: string;
    profilePicOverride?: string;
    currentAvatarThumbnailImageUrl?: string | null;
    currentAvatarTags?: Array<Tag>;
};

export type GroupMember = {
    id?: GroupMemberID;
    groupId?: GroupID;
    userId?: UserID;
    /**
     * Whether the user is representing the group. This makes the group show up above the name tag in-game.
     */
    isRepresenting?: boolean;
    user?: GroupMemberLimitedUser | null;
    roleIds?: Array<GroupRoleID>;
    mRoleIds?: Array<GroupRoleID>;
    joinedAt?: string | null;
    membershipStatus?: GroupMemberStatus;
    visibility?: string;
    isSubscribedToAnnouncements?: boolean;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    createdAt?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    bannedAt?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    managerNotes?: string | null;
    lastPostReadAt?: string | null;
    hasJoinedFromPurchase?: boolean;
};

export type BanGroupMemberRequest = {
    userId: UserID;
};

export type CreateGroupGalleryRequest = {
    /**
     * Name of the gallery.
     */
    name: string;
    /**
     * Description of the gallery.
     */
    description?: string;
    /**
     * Whether the gallery is members only.
     */
    membersOnly?: boolean;
    /**
     *
     */
    roleIdsToView?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToSubmit?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToAutoApprove?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToManage?: Array<GroupRoleID> | null;
};

export type GroupGalleryImageID = string;

export type GroupGalleryImage = {
    id?: GroupGalleryImageID;
    groupId?: GroupID;
    galleryId?: GroupGalleryID;
    fileId?: FileID;
    imageUrl?: string;
    createdAt?: string;
    submittedByUserId?: UserID;
    approved?: boolean;
    approvedByUserId?: UserID;
    approvedAt?: string;
};

export type UpdateGroupGalleryRequest = {
    /**
     * Name of the gallery.
     */
    name?: string;
    /**
     * Description of the gallery.
     */
    description?: string;
    /**
     * Whether the gallery is members only.
     */
    membersOnly?: boolean;
    /**
     *
     */
    roleIdsToView?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToSubmit?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToAutoApprove?: Array<GroupRoleID> | null;
    /**
     *
     */
    roleIdsToManage?: Array<GroupRoleID> | null;
};

export type AddGroupGalleryImageRequest = {
    fileId: FileID;
};

/**
 * InstanceID can be "offline" on User profiles if you are not friends with that user and "private" if you are friends and user is in private instance.
 */
export type InstanceID = string;

/**
 * A unique ID of a Udon Product
 */
export type UdonProductId = string;

export type World = {
    authorId: UserID;
    authorName: string;
    capacity: number;
    recommendedCapacity: number;
    created_at: string;
    description: string;
    favorites?: number;
    featured: boolean;
    heat: number;
    id: WorldID;
    imageUrl: string;
    /**
     * Will always be an empty list when unauthenticated.
     */
    instances?: Array<[
        unknown,
        unknown
    ]>;
    labsPublicationDate: string;
    name: string;
    namespace?: string;
    /**
     * Will always be `0` when unauthenticated.
     */
    occupants?: number;
    organization: string;
    popularity: number;
    previewYoutubeId?: string | null;
    /**
     * Will always be `0` when unauthenticated.
     */
    privateOccupants?: number;
    /**
     * Will always be `0` when unauthenticated.
     */
    publicOccupants?: number;
    publicationDate: string;
    releaseStatus: ReleaseStatus;
    /**
     *
     */
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    /**
     * Empty if unauthenticated.
     */
    unityPackages?: Array<UnityPackage>;
    updated_at: string;
    version: number;
    visits: number;
    udonProducts?: Array<UdonProductId>;
};

export type GroupInstance = {
    instanceId: string;
    location: InstanceID;
    world: World;
    memberCount: number;
};

export type CreateGroupInviteRequest = {
    userId: UserID;
    confirmOverrideBlock?: boolean;
};

export type GroupSearchSort = 'joinedAt:asc' | 'joinedAt:desc';

export type GroupLimitedMember = {
    id?: GroupMemberID;
    groupId?: GroupID;
    userId?: UserID;
    /**
     * Whether the user is representing the group. This makes the group show up above the name tag in-game.
     */
    isRepresenting?: boolean;
    roleIds?: Array<GroupRoleID>;
    mRoleIds?: Array<GroupRoleID>;
    joinedAt?: string | null;
    membershipStatus?: GroupMemberStatus;
    visibility?: string;
    isSubscribedToAnnouncements?: boolean;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    createdAt?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    bannedAt?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    managerNotes?: string | null;
    lastPostReadAt?: string | null;
    hasJoinedFromPurchase?: boolean;
};

export type GroupUserVisibility = 'visible' | 'hidden' | 'friends';

export type UpdateGroupMemberRequest = {
    visibility?: GroupUserVisibility;
    isSubscribedToAnnouncements?: boolean;
    managerNotes?: string;
};

/**
 *
 */
export type GroupRoleIDList = Array<GroupRoleID>;

/**
 * A permission that can be granted to a role in a group.
 */
export type GroupPermission = {
    /**
     * The name of the permission.
     */
    name?: string;
    /**
     * The display name of the permission.
     */
    displayName?: string;
    /**
     * Human-readable description of the permission.
     */
    help?: string;
    /**
     * Whether this permission is a "management" permission.
     */
    isManagementPermission?: boolean;
    /**
     * Whether the user is allowed to add this permission to a role.
     */
    allowedToAdd?: boolean;
};

export type NotificationID = string;

export type GroupPostVisibility = 'group' | 'public';

export type GroupPost = {
    id?: NotificationID;
    groupId?: GroupID;
    authorId?: UserID;
    editorId?: UserID | null;
    visibility?: GroupPostVisibility;
    roleId?: GroupRoleIDList;
    title?: string;
    text?: string;
    imageId?: FileID | null;
    imageUrl?: string | null;
    createdAt?: string;
    updatedAt?: string;
};

export type CreateGroupPostRequest = {
    /**
     * Post title
     */
    title: string;
    /**
     * Post text
     */
    text: string;
    imageId?: FileID;
    /**
     * Send notification to group members.
     */
    sendNotification: boolean;
    roleIds?: GroupRoleIDList;
    visibility: GroupPostVisibility;
};

export type GroupJoinRequestAction = 'accept' | 'reject';

export type RespondGroupJoinRequest = {
    action: GroupJoinRequestAction;
    /**
     * Whether to block the user from requesting again
     */
    block?: boolean;
};

export type CreateGroupRoleRequest = {
    id?: string;
    name?: string;
    description?: string;
    isSelfAssignable?: boolean;
    permissions?: Array<(string)>;
};

export type UpdateGroupRoleRequest = {
    name?: string;
    description?: string;
    isSelfAssignable?: boolean;
    permissions?: Array<(string)>;
    order?: number;
};

export type InviteRequest = {
    instanceId: InstanceID;
    messageSlot?: number;
};

export type SentNotification = {
    created_at: string;
    details: {
        [key: string]: unknown;
    };
    id: string;
    message: string;
    receiverUserId: UserID;
    senderUserId: UserID;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    senderUsername?: string;
    type: NotificationType;
};

export type RequestInviteRequest = {
    messageSlot?: number;
};

export type InviteResponse = {
    responseSlot: number;
};

export type InviteMessageType = 'message' | 'response' | 'request' | 'requestResponse';

export type InviteMessageID = string;

export type InviteMessage = {
    canBeUpdated: boolean;
    id: InviteMessageID;
    message: string;
    messageType: InviteMessageType;
    /**
     * Changes to 60 when updated, although probably server-side configurable.
     */
    remainingCooldownMinutes: number;
    slot: number;
    updatedAt: string;
};

export type UpdateInviteMessageRequest = {
    message: string;
};

export type InstanceType = 'public' | 'hidden' | 'friends' | 'private' | 'group';

/**
 * Instance region
 */
export type InstanceRegion = 'us' | 'use' | 'eu' | 'jp';

/**
 * A groupId if the instance type is "group", null if instance type is public, or a userId otherwise
 */
export type InstanceOwnerId = string | null;

/**
 * Group access type when the instance type is "group"
 */
export type GroupAccessType = 'public' | 'plus' | 'members';

export type CreateInstanceRequest = {
    worldId: WorldID;
    type: InstanceType;
    region: InstanceRegion;
    ownerId?: InstanceOwnerId;
    /**
     * Group roleIds that are allowed to join if the type is "group" and groupAccessType is "member"
     */
    roleIds?: Array<GroupRoleID>;
    groupAccessType?: GroupAccessType;
    queueEnabled?: boolean;
    /**
     * The time after which users won't be allowed to join the instance. This doesn't work for public instances.
     */
    closedAt?: string;
    /**
     * Only applies to invite type instances to make them invite+
     */
    canRequestInvite?: boolean;
    /**
     * Currently unused, but will eventually be a flag to set if the closing of the instance should kick people.
     */
    hardClose?: boolean;
    inviteOnly?: boolean;
};

/**
 * API/Photon region.
 */
export type Region = 'us' | 'use' | 'usw' | 'eu' | 'jp' | 'unknown';

export type InstancePlatforms = {
    android: number;
    standalonewindows: number;
};

/**
 * * `hidden` field is only present if InstanceType is `hidden` aka "Friends+", and is instance creator.
 * * `friends` field is only present if InstanceType is `friends` aka "Friends", and is instance creator.
 * * `private` field is only present if InstanceType is `private` aka "Invite" or "Invite+", and is instance creator.
 */
export type Instance = {
    active: boolean;
    canRequestInvite: boolean;
    capacity: number;
    /**
     * Always returns "unknown".
     * @deprecated
     */
    clientNumber: string;
    full: boolean;
    id: InstanceID;
    instanceId: string;
    location: InstanceID;
    n_users: number;
    name: string;
    ownerId?: InstanceOwnerId;
    permanent: boolean;
    photonRegion: Region;
    platforms: InstancePlatforms;
    region: InstanceRegion;
    secureName: string;
    shortName?: string | null;
    /**
     * The tags array on Instances usually contain the language tags of the people in the instance.
     */
    tags: Array<Tag>;
    type: InstanceType;
    worldId: WorldID;
    hidden?: UserID;
    friends?: UserID;
    private?: UserID;
    queueEnabled: boolean;
    queueSize: number;
    recommendedCapacity: number;
    roleRestricted?: boolean;
    strict: boolean;
    userCount: number;
    world: World;
    /**
     * The users field is present on instances created by the requesting user.
     */
    users?: Array<LimitedUser>;
    groupAccessType?: GroupAccessType;
    hasCapacityForYou?: boolean;
    nonce?: string;
    closedAt?: string | null;
    hardClose?: boolean | null;
};

export type InstanceShortNameResponse = {
    secureName: string;
    shortName?: string;
};

export type PermissionID = string;

export type Permission = {
    id: PermissionID;
    name: string;
    ownerId: UserID;
    data?: {
        [key: string]: unknown;
    };
};

export type PlayerModerationID = string;

export type PlayerModerationType = 'mute' | 'unmute' | 'block' | 'unblock' | 'interactOn' | 'interactOff';

export type PlayerModeration = {
    created: string;
    id: PlayerModerationID;
    sourceDisplayName: string;
    sourceUserId: UserID;
    targetDisplayName: string;
    targetUserId: UserID;
    type: PlayerModerationType;
};

export type ModerateUserRequest = {
    moderated: UserID;
    type: PlayerModerationType;
};

/**
 * Public Announcement
 * @deprecated
 */
export type APIConfigAnnouncement = {
    /**
     * Announcement name
     */
    name: string;
    /**
     * Announcement text
     */
    text: string;
};

/**
 * Used to identify which API deployment cluster is currently responding.
 *
 * `blue` and `green` are used by Production.
 * `grape`and `cherry` are used during Development.
 *
 * [Blue Green Deployment by Martin Fowler](https://martinfowler.com/bliki/BlueGreenDeployment.html)
 */
export type DeploymentGroup = 'blue' | 'green' | 'grape' | 'cherry';

/**
 * Download links for various development assets.
 */
export type APIConfigDownloadURLList = {
    /**
     * Download link for legacy SDK2
     * @deprecated
     */
    sdk2: string;
    /**
     * Download link for SDK3 for Avatars
     */
    'sdk3-avatars': string;
    /**
     * Download link for SDK3 for Worlds
     */
    'sdk3-worlds': string;
    /**
     * Download link for the Creator Companion
     */
    vcc: string;
    /**
     * Download link for ???
     */
    bootstrap: string;
};

export type DynamicContentRow = {
    index?: number;
    name: string;
    /**
     * Usually "ThisPlatformSupported", but can also be other values such as "all" or platform specific identifiers.
     */
    platform: string;
    sortHeading: string;
    sortOrder: string;
    sortOwnership: string;
    /**
     * Tag to filter content for this row.
     */
    tag?: string;
    /**
     * Type is not present if it is a world.
     */
    type?: string;
};

export type APIConfigEvents = {
    /**
     * Unknown
     */
    distanceClose: number;
    /**
     * Unknown
     */
    distanceFactor: number;
    /**
     * Unknown
     */
    distanceFar: number;
    /**
     * Unknown
     */
    groupDistance: number;
    /**
     * Unknown
     */
    maximumBunchSize: number;
    /**
     * Unknown
     */
    notVisibleFactor: number;
    /**
     * Unknown
     */
    playerOrderBucketSize: number;
    /**
     * Unknown
     */
    playerOrderFactor: number;
    /**
     * Unknown
     */
    slowUpdateFactorThreshold: number;
    /**
     * Unknown
     */
    viewSegmentLength: number;
};

export type APIConfig = {
    /**
     * Unknown, probably voice optimization testing
     */
    VoiceEnableDegradation: boolean;
    /**
     * Unknown, probably voice optimization testing
     */
    VoiceEnableReceiverLimiting: boolean;
    /**
     * VRChat's office address
     */
    address: string;
    /**
     * Public Announcements
     */
    announcements: Array<APIConfigAnnouncement>;
    /**
     * Game name
     * @deprecated
     */
    appName: string;
    /**
     * Build tag of the API server
     */
    buildVersionTag: string;
    /**
     * apiKey to be used for all other requests
     */
    clientApiKey: string;
    /**
     * Unknown
     */
    clientBPSCeiling: number;
    /**
     * Unknown
     */
    clientDisconnectTimeout: number;
    /**
     * Unknown
     */
    clientReservedPlayerBPS: number;
    /**
     * Unknown
     */
    clientSentCountAllowance: number;
    /**
     * VRChat's contact email
     */
    contactEmail: string;
    /**
     * VRChat's copyright-issues-related email
     */
    copyrightEmail: string;
    /**
     * Current version number of the Terms of Service
     */
    currentTOSVersion: number;
    defaultAvatar: AvatarID;
    deploymentGroup: DeploymentGroup;
    /**
     * Version number for game development build
     * @deprecated
     */
    devAppVersionStandalone: string;
    /**
     * Developer Download link
     * @deprecated
     */
    devDownloadLinkWindows: string;
    /**
     * Link to download the development SDK, use downloadUrls instead
     * @deprecated
     */
    devSdkUrl: string;
    /**
     * Version of the development SDK
     * @deprecated
     */
    devSdkVersion: string;
    /**
     * Version number for server development build
     * @deprecated
     */
    devServerVersionStandalone: string;
    /**
     * Unknown, "dis" maybe for disconnect?
     */
    'dis-countdown': string;
    /**
     * Toggles if copying avatars should be disabled
     */
    disableAvatarCopying: boolean;
    /**
     * Toggles if avatar gating should be disabled. Avatar gating restricts uploading of avatars to people with the `system_avatar_access` Tag or `admin_avatar_access` Tag
     */
    disableAvatarGating: boolean;
    /**
     * Toggles if the Community Labs should be disabled
     */
    disableCommunityLabs: boolean;
    /**
     * Toggles if promotion out of Community Labs should be disabled
     */
    disableCommunityLabsPromotion: boolean;
    /**
     * Unknown
     */
    disableEmail: boolean;
    /**
     * Toggles if Analytics should be disabled.
     */
    disableEventStream: boolean;
    /**
     * Toggles if feedback gating should be disabled. Feedback gating restricts submission of feedback (reporting a World or User) to people with the `system_feedback_access` Tag.
     */
    disableFeedbackGating: boolean;
    /**
     * Unknown, probably toggles compilation of frontend web builds? So internal flag?
     */
    disableFrontendBuilds: boolean;
    /**
     * Unknown
     */
    disableHello: boolean;
    /**
     * Toggles if signing up for Subscriptions in Oculus is disabled or not.
     */
    disableOculusSubs: boolean;
    /**
     * Toggles if new user account registration should be disabled.
     */
    disableRegistration: boolean;
    /**
     * Toggles if Steam Networking should be disabled. VRChat these days uses Photon Unity Networking (PUN) instead.
     */
    disableSteamNetworking: boolean;
    /**
     * Toggles if 2FA should be disabled.
     * @deprecated
     */
    disableTwoFactorAuth: boolean;
    /**
     * Toggles if Udon should be universally disabled in-game.
     */
    disableUdon: boolean;
    /**
     * Toggles if account upgrading "linking with Steam/Oculus" should be disabled.
     */
    disableUpgradeAccount: boolean;
    /**
     * Download link for game on the Oculus Rift website.
     */
    downloadLinkWindows: string;
    downloadUrls: APIConfigDownloadURLList;
    /**
     * Array of DynamicWorldRow objects, used by the game to display the list of world rows
     */
    dynamicWorldRows: Array<DynamicContentRow>;
    events: APIConfigEvents;
    /**
     * Unknown
     * @deprecated
     */
    gearDemoRoomId: string;
    homeWorldId: WorldID;
    /**
     * Redirect target if you try to open the base API domain in your browser
     */
    homepageRedirectTarget: string;
    hubWorldId: WorldID;
    /**
     * VRChat's job application email
     */
    jobsEmail: string;
    /**
     * MOTD
     * @deprecated
     */
    messageOfTheDay: string;
    /**
     * VRChat's moderation related email
     */
    moderationEmail: string;
    /**
     * Unknown
     */
    moderationQueryPeriod: number;
    /**
     * Used in-game to notify a user they aren't allowed to select avatars in private worlds
     */
    notAllowedToSelectAvatarInPrivateWorldMessage: string;
    /**
     * Extra [plugin](https://doc.photonengine.com/en-us/server/current/plugins/manual) to run in each instance
     */
    plugin: string;
    /**
     * Version number for game release build
     * @deprecated
     */
    releaseAppVersionStandalone: string;
    /**
     * Link to download the release SDK
     * @deprecated
     */
    releaseSdkUrl: string;
    /**
     * Version of the release SDK
     * @deprecated
     */
    releaseSdkVersion: string;
    /**
     * Version number for server release build
     * @deprecated
     */
    releaseServerVersionStandalone: string;
    /**
     * Link to the developer FAQ
     */
    sdkDeveloperFaqUrl: string;
    /**
     * Link to the official VRChat Discord
     */
    sdkDiscordUrl: string;
    /**
     * Used in the SDK to notify a user they aren't allowed to upload avatars/worlds yet
     */
    sdkNotAllowedToPublishMessage: string;
    /**
     * Unity version supported by the SDK
     */
    sdkUnityVersion: string;
    /**
     * Server name of the API server currently responding
     */
    serverName: string;
    /**
     * VRChat's support email
     */
    supportEmail: string;
    timeOutWorldId: WorldID;
    tutorialWorldId: WorldID;
    /**
     * Unknown
     */
    updateRateMsMaximum: number;
    /**
     * Unknown
     */
    updateRateMsMinimum: number;
    /**
     * Unknown
     */
    updateRateMsNormal: number;
    /**
     * Unknown
     */
    updateRateMsUdonManual: number;
    /**
     * Unknown
     */
    uploadAnalysisPercent: number;
    /**
     * List of allowed URLs that bypass the "Allow untrusted URL's" setting in-game
     */
    urlList: Array<(string)>;
    /**
     * Unknown
     */
    useReliableUdpForVoice: boolean;
    /**
     * Unknown
     */
    userUpdatePeriod: number;
    /**
     * Unknown
     */
    userVerificationDelay: number;
    /**
     * Unknown
     */
    userVerificationRetry: number;
    /**
     * Unknown
     */
    userVerificationTimeout: number;
    /**
     * Download link for game on the Steam website.
     */
    viveWindowsUrl: string;
    /**
     * List of allowed URLs that are allowed to host avatar assets
     */
    whiteListedAssetUrls: Array<(string)>;
    /**
     * Unknown
     */
    worldUpdatePeriod: number;
    /**
     * Currently used youtube-dl.exe hash in SHA-256-delimited format
     */
    'player-url-resolver-hash': string;
    /**
     * Currently used youtube-dl.exe version
     */
    'player-url-resolver-version': string;
};

export type InfoPushDataClickable = {
    command: 'OpenURL' | 'OpenVRCPlusMenu' | 'OpenSafetyMenu' | 'CannedWorldSearch';
    /**
     * In case of OpenURL, this would contain the link.
     */
    parameters?: Array<(string)>;
};

export type command = 'OpenURL' | 'OpenVRCPlusMenu' | 'OpenSafetyMenu' | 'CannedWorldSearch';

export type InfoPushDataArticleContent = {
    text?: string;
    imageUrl?: string;
    onPressed?: InfoPushDataClickable;
};

export type InfoPushDataArticle = {
    content?: InfoPushDataArticleContent;
};

export type InfoPushData = {
    contentList?: DynamicContentRow;
    description?: string;
    imageUrl?: string;
    name?: string;
    onPressed?: InfoPushDataClickable;
    template?: string;
    version?: string;
    article?: InfoPushDataArticle;
};

export type InfoPush = {
    id: string;
    isEnabled: boolean;
    releaseStatus: ReleaseStatus;
    priority: number;
    /**
     *
     */
    tags: Array<Tag>;
    data: InfoPushData;
    /**
     * Unknown usage, MD5
     */
    hash: string;
    createdAt: string;
    updatedAt: string;
    startDate?: string;
    endDate?: string;
};

export type APIHealth = {
    ok: boolean;
    serverName: string;
    buildVersionTag: string;
};

export type User = {
    allowAvatarCopying: boolean;
    /**
     *
     */
    badges?: Array<Badge>;
    bio: string;
    bioLinks: Array<(string)>;
    currentAvatarImageUrl: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags: Array<Tag>;
    date_joined: string;
    developerType: DeveloperType;
    /**
     * A users visual display name. This is what shows up in-game, and can different from their `username`. Changing display name is restricted to a cooldown period.
     */
    displayName: string;
    friendKey: string;
    friendRequestStatus?: string;
    id: UserID;
    instanceId?: InstanceID;
    /**
     * Either their `friendKey`, or empty string if you are not friends. Unknown usage.
     */
    isFriend: boolean;
    /**
     * Either a date-time or empty string.
     */
    last_activity: string;
    /**
     * Either a date-time or empty string.
     */
    last_login: string;
    last_platform: Platform;
    location?: WorldID;
    note?: string;
    profilePicOverride: string;
    pronouns: string;
    state: UserState;
    status: UserStatus;
    statusDescription: string;
    /**
     *
     */
    tags: Array<Tag>;
    travelingToInstance?: string;
    travelingToLocation?: string;
    travelingToWorld?: string;
    userIcon: string;
    /**
     * -| A users unique name, used during login. This is different from `displayName` which is what shows up in-game. A users `username` can never be changed.'
     * **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    username?: string;
    worldId?: WorldID;
};

export type UpdateUserRequest = {
    email?: string;
    birthday?: string;
    acceptedTOSVersion?: number;
    /**
     *
     */
    tags?: Array<Tag>;
    status?: UserStatus;
    statusDescription?: string;
    bio?: string;
    bioLinks?: Array<(string)>;
    pronouns?: string;
    /**
     * MUST be a valid VRChat /file/ url.
     */
    userIcon?: string;
};

export type LimitedUserGroups = {
    id?: GroupMemberID;
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconId?: string | null;
    iconUrl?: string | null;
    bannerId?: string | null;
    bannerUrl?: string | null;
    privacy?: string;
    lastPostCreatedAt?: string | null;
    ownerId?: UserID;
    memberCount?: number;
    groupId?: GroupID;
    memberVisibility?: string;
    isRepresenting?: boolean;
    mutualGroup?: boolean;
    lastPostReadAt?: string | null;
};

export type representedGroup = {
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconId?: string | null;
    iconUrl?: string | null;
    bannerId?: string | null;
    bannerUrl?: string | null;
    privacy?: GroupPrivacy;
    ownerId?: UserID;
    memberCount?: number;
    groupId?: GroupID;
    memberVisibility?: GroupUserVisibility;
    isRepresenting?: boolean;
};

export type LimitedUnityPackage = {
    platform: Platform;
    unityVersion: string;
};

export type LimitedWorld = {
    authorId: UserID;
    authorName: string;
    capacity: number;
    recommendedCapacity?: number;
    created_at: string;
    favorites: number;
    visits?: number;
    heat: number;
    id: WorldID;
    imageUrl: string;
    labsPublicationDate: string;
    name: string;
    occupants: number;
    organization: string;
    popularity: number;
    previewYoutubeId?: string | null;
    publicationDate: string;
    releaseStatus: ReleaseStatus;
    /**
     *
     */
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    /**
     *
     */
    unityPackages: Array<LimitedUnityPackage>;
    updated_at: string;
    udonProducts?: Array<UdonProductId>;
};

export type CreateWorldRequest = {
    assetUrl: string;
    assetVersion?: number;
    authorId?: UserID;
    authorName?: string;
    capacity?: number;
    description?: string;
    id?: WorldID;
    imageUrl: string;
    name: string;
    platform?: Platform;
    releaseStatus?: ReleaseStatus;
    /**
     *
     */
    tags?: Array<Tag>;
    unityPackageUrl?: string;
    unityVersion?: string;
};

export type UpdateWorldRequest = {
    assetUrl?: string;
    assetVersion?: string;
    authorId?: UserID;
    authorName?: string;
    capacity?: number;
    description?: string;
    imageUrl?: string;
    name?: string;
    platform?: Platform;
    releaseStatus?: ReleaseStatus;
    /**
     *
     */
    tags?: Array<Tag>;
    unityPackageUrl?: string;
    unityVersion?: string;
};

export type WorldMetadata = {
    id: WorldID;
    metadata: {
        [key: string]: unknown;
    };
};

export type WorldPublishStatus = {
    canPublish: boolean;
};

export type NotificationDetailInvite = {
    inviteMessage?: string;
    worldId: WorldID;
    worldName: string;
};

export type NotificationDetailInviteResponse = {
    inResponseTo: NotificationID;
    responseMessage: string;
};

export type NotificationDetailRequestInvite = {
    /**
     * TODO: Does this still exist?
     */
    platform?: string;
    /**
     * Used when using InviteMessage Slot.
     */
    requestMessage?: string;
};

export type NotificationDetailRequestInviteResponse = {
    inResponseTo: NotificationID;
    /**
     * Used when using InviteMessage Slot.
     */
    requestMessage?: string;
};

export type NotificationDetailVoteToKick = {
    initiatorUserId: UserID;
    userToKickId: UserID;
};

/**
 * Filter by email.
 */
export type Parameteremail = string;

/**
 * Filter by displayName.
 */
export type ParameterdisplayName = string;

/**
 * Filter by UserID.
 */
export type ParameteruserIdQuery = string;

/**
 * Exclude by UserID.
 */
export type ParameterexcludeUserId = string;

/**
 * Must be a valid user ID.
 */
export type ParameteruserId = string;

/**
 * Filters on featured results.
 */
export type Parameterfeatured = boolean;

/**
 * The sort order of the results.
 */
export type Parametersort = SortOption;

/**
 * The number of objects to return.
 */
export type Parameternumber = number;

/**
 * Result ordering
 */
export type Parameterorder = OrderOption;

/**
 * A zero-based offset from the default object sorting from where search results start.
 */
export type Parameteroffset = number;

/**
 * Tags to include (comma-separated). Any of the tags needs to be present.
 */
export type Parametertag = string;

/**
 * Tags to exclude (comma-separated).
 */
export type Parameternotag = string;

/**
 * Filter by ReleaseStatus.
 */
export type ParameterreleaseStatus = ReleaseStatus;

/**
 * The maximum Unity version supported by the asset.
 */
export type ParametermaxUnityVersion = string;

/**
 * The minimum Unity version supported by the asset.
 */
export type ParameterminUnityVersion = string;

/**
 * The platform the asset supports.
 */
export type Parameterplatform = string;

/**
 * Must be a valid avatar ID.
 */
export type ParameteravatarId = string;

/**
 * Filters by world name.
 */
export type Parametersearch = string;

/**
 * Target user to see information on, admin-only.
 */
export type ParameteruserIdAdmin = string;

/**
 * Must be a valid transaction ID.
 */
export type ParametertransactionId = string;

/**
 * Must be a valid license group ID.
 */
export type ParameterlicenseGroupId = string;

/**
 * Must be a valid favorite ID.
 */
export type ParameterfavoriteId = string;

/**
 * The type of group to fetch, must be a valid FavoriteType.
 */
export type ParameterfavoriteGroupType = 'world' | 'friend' | 'avatar';

/**
 * The name of the group to fetch, must be a name of a FavoriteGroup.
 */
export type ParameterfavoriteGroupName = string;

/**
 * Must be a valid file ID.
 */
export type ParameterfileId = string;

/**
 * Version ID of the asset.
 */
export type ParameterversionId = number;

/**
 * Type of file.
 */
export type ParameterfileType = 'file' | 'signature' | 'delta';

/**
 * Returns *only* offline users if true, returns only online and active users if false
 */
export type Parameteroffline = boolean;

/**
 * Must be a valid group ID.
 */
export type ParametergroupId = string;

/**
 * The start date of the search range.
 */
export type ParameterstartDate = string;

/**
 * The end date of the search range.
 */
export type ParameterendDate = string;

/**
 * Must be a valid group gallery ID.
 */
export type ParametergroupGalleryId = string;

/**
 * Must be a valid group gallery image ID.
 */
export type ParametergroupGalleryImageId = string;

/**
 * The sort order of Group Member results
 */
export type ParametergroupMemberSort = GroupSearchSort;

/**
 * Must be a valid group role ID.
 */
export type ParametergroupRoleId = string;

/**
 * Must be a valid notification ID.
 */
export type ParameternotificationId = string;

/**
 * Must be a valid world ID.
 */
export type ParameterworldId = string;

/**
 * Must be a valid instance ID.
 */
export type ParameterinstanceId = string;

/**
 * The type of message to fetch, must be a valid InviteMessageType.
 */
export type ParametermessageType = InviteMessageType;

/**
 * The message slot to fetch of a given message type.
 */
export type Parameterslot = number;

/**
 * Must be a valid permission ID.
 */
export type ParameterpermissionId = string;

/**
 * Tags to include (comma-separated). All of the tags needs to be present.
 */
export type Parameterrequire = string;

/**
 * Tags to include (comma-separated). Any of the tags needs to be present.
 */
export type Parameterinclude = string;

/**
 * Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management.
 */
export type Parametervariant = 'public' | 'internal';

/**
 * Specifies which git branch the site should load frontend source code from.
 */
export type Parameterbranch = string;

export type CheckUserExistsData = {
    query?: {
        /**
         * Filter by displayName.
         */
        displayName?: string;
        /**
         * Filter by email.
         */
        email?: string;
        /**
         * Exclude by UserID.
         */
        excludeUserId?: string;
        /**
         * Filter by UserID.
         */
        userId?: string;
    };
};

export type CheckUserExistsResponse = UserExists;

export type CheckUserExistsError = unknown;

export type GetCurrentUserResponse = CurrentUser;

export type GetCurrentUserError = unknown;

export type Verify2FaData = {
    body: TwoFactorAuthCode;
};

export type Verify2FaResponse = Verify2FAResult;

export type Verify2FaError = unknown;

export type VerifyRecoveryCodeData = {
    body: TwoFactorAuthCode;
};

export type VerifyRecoveryCodeResponse = Verify2FAResult;

export type VerifyRecoveryCodeError = unknown;

export type Verify2FaEmailCodeData = {
    body: TwoFactorEmailCode;
};

export type Verify2FaEmailCodeResponse = Verify2FAEmailCodeResult;

export type Verify2FaEmailCodeError = unknown;

export type VerifyAuthTokenResponse = VerifyAuthTokenResult;

export type VerifyAuthTokenError = unknown;

export type LogoutResponse = Success;

export type LogoutError = unknown;

export type DeleteUserData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type DeleteUserResponse = CurrentUser;

export type DeleteUserError = unknown;

export type GetOwnAvatarData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetOwnAvatarResponse = Avatar;

export type GetOwnAvatarError = unknown;

export type SearchAvatarsData = {
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Set to `me` for searching own avatars.
         */
        user?: 'me';
        /**
         * Filter by UserID.
         */
        userId?: string;
    };
};

export type SearchAvatarsResponse = Array<Avatar>;

export type SearchAvatarsError = unknown;

export type CreateAvatarData = {
    body?: CreateAvatarRequest;
};

export type CreateAvatarResponse = Avatar;

export type CreateAvatarError = unknown;

export type GetAvatarData = {
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
};

export type GetAvatarResponse = Avatar;

export type GetAvatarError = unknown;

export type UpdateAvatarData = {
    body?: UpdateAvatarRequest;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
};

export type UpdateAvatarResponse = Avatar;

export type UpdateAvatarError = unknown;

export type DeleteAvatarData = {
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
};

export type DeleteAvatarResponse = Avatar;

export type DeleteAvatarError = unknown;

export type SelectAvatarData = {
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
};

export type SelectAvatarResponse = CurrentUser;

export type SelectAvatarError = unknown;

export type SelectFallbackAvatarData = {
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
};

export type SelectFallbackAvatarResponse = CurrentUser;

export type SelectFallbackAvatarError = unknown;

export type GetFavoritedAvatarsData = {
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Target user to see information on, admin-only.
         */
        userId?: string;
    };
};

export type GetFavoritedAvatarsResponse = Array<Avatar>;

export type GetFavoritedAvatarsError = unknown;

export type GetSteamTransactionsResponse = Array<Transaction>;

export type GetSteamTransactionsError = unknown;

export type GetSteamTransactionData = {
    path: {
        /**
         * Must be a valid transaction ID.
         */
        transactionId: string;
    };
};

export type GetSteamTransactionResponse = Transaction;

export type GetSteamTransactionError = unknown;

export type GetCurrentSubscriptionsResponse = Array<UserSubscription>;

export type GetCurrentSubscriptionsError = unknown;

export type GetSubscriptionsResponse = Array<Subscription>;

export type GetSubscriptionsError = unknown;

export type GetLicenseGroupData = {
    path: {
        /**
         * Must be a valid license group ID.
         */
        licenseGroupId: string;
    };
};

export type GetLicenseGroupResponse = LicenseGroup;

export type GetLicenseGroupError = unknown;

export type GetFavoritesData = {
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * The type of favorites to return, FavoriteType.
         */
        type?: string;
    };
};

export type GetFavoritesResponse = Array<Favorite>;

export type GetFavoritesError = unknown;

export type AddFavoriteData = {
    body?: AddFavoriteRequest;
};

export type AddFavoriteResponse = Favorite;

export type AddFavoriteError = unknown;

export type GetFavoriteData = {
    path: {
        /**
         * Must be a valid favorite ID.
         */
        favoriteId: string;
    };
};

export type GetFavoriteResponse = Favorite;

export type GetFavoriteError = unknown;

export type RemoveFavoriteData = {
    path: {
        /**
         * Must be a valid favorite ID.
         */
        favoriteId: string;
    };
};

export type RemoveFavoriteResponse = Success;

export type RemoveFavoriteError = unknown;

export type GetFavoriteGroupsData = {
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The owner of whoms favorite groups to return. Must be a UserID.
         */
        ownerId?: string;
    };
};

export type GetFavoriteGroupsResponse = Array<FavoriteGroup>;

export type GetFavoriteGroupsError = unknown;

export type GetFavoriteGroupData = {
    path: {
        /**
         * The name of the group to fetch, must be a name of a FavoriteGroup.
         */
        favoriteGroupName: string;
        /**
         * The type of group to fetch, must be a valid FavoriteType.
         */
        favoriteGroupType: 'world' | 'friend' | 'avatar';
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetFavoriteGroupResponse = FavoriteGroup;

export type GetFavoriteGroupError = unknown;

export type UpdateFavoriteGroupData = {
    body?: UpdateFavoriteGroupRequest;
    path: {
        /**
         * The name of the group to fetch, must be a name of a FavoriteGroup.
         */
        favoriteGroupName: string;
        /**
         * The type of group to fetch, must be a valid FavoriteType.
         */
        favoriteGroupType: 'world' | 'friend' | 'avatar';
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type UpdateFavoriteGroupResponse = unknown;

export type UpdateFavoriteGroupError = unknown;

export type ClearFavoriteGroupData = {
    path: {
        /**
         * The name of the group to fetch, must be a name of a FavoriteGroup.
         */
        favoriteGroupName: string;
        /**
         * The type of group to fetch, must be a valid FavoriteType.
         */
        favoriteGroupType: 'world' | 'friend' | 'avatar';
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type ClearFavoriteGroupResponse = Success;

export type ClearFavoriteGroupError = unknown;

export type GetFilesData = {
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Tag, for example "icon" or "gallery", not included by default.
         */
        tag?: string;
        /**
         * UserID, will always generate a 500 permission error.
         * @deprecated
         */
        userId?: string;
    };
};

export type GetFilesResponse = Array<File>;

export type GetFilesError = unknown;

export type CreateFileData = {
    body?: CreateFileRequest;
};

export type CreateFileResponse = File;

export type CreateFileError = unknown;

export type GetFileData = {
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
    };
};

export type GetFileResponse = File;

export type GetFileError = unknown;

export type DeleteFileData = {
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
    };
};

export type DeleteFileResponse = Success;

export type DeleteFileError = unknown;

export type CreateFileVersionData = {
    body?: CreateFileVersionRequest;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
    };
};

export type CreateFileVersionResponse = File;

export type CreateFileVersionError = unknown;

export type DownloadFileVersionData = {
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
};

export type DownloadFileVersionResponse = unknown;

export type DownloadFileVersionError = unknown;

export type DeleteFileVersionData = {
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
};

export type DeleteFileVersionResponse = File;

export type DeleteFileVersionError = unknown;

export type FinishFileDataUploadData = {
    /**
     * Please see documentation on ETag's:
     * [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)
     *
     * ETag's should NOT be present when uploading a `signature`.
     */
    body?: FinishFileDataUploadRequest;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Type of file.
         */
        fileType: 'file' | 'signature' | 'delta';
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
};

export type FinishFileDataUploadResponse = File;

export type FinishFileDataUploadError = unknown;

export type StartFileDataUploadData = {
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Type of file.
         */
        fileType: 'file' | 'signature' | 'delta';
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
    query?: {
        /**
         * The part number to start uploading. If not provided, the first part will be started.
         * @deprecated
         */
        partNumber?: number;
    };
};

export type StartFileDataUploadResponse = FileUploadURL;

export type StartFileDataUploadError = unknown;

export type GetFileDataUploadStatusData = {
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Type of file.
         */
        fileType: 'file' | 'signature' | 'delta';
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
};

export type GetFileDataUploadStatusResponse = FileVersionUploadStatus;

export type GetFileDataUploadStatusError = unknown;

export type GetFriendsData = {
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Returns *only* offline users if true, returns only online and active users if false
         */
        offline?: boolean;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
};

export type GetFriendsResponse = Array<LimitedUser>;

export type GetFriendsError = unknown;

export type FriendData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type FriendResponse = Notification;

export type FriendError = unknown;

export type DeleteFriendRequestData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type DeleteFriendRequestResponse = Success;

export type DeleteFriendRequestError = unknown;

export type GetFriendStatusData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetFriendStatusResponse = FriendStatus;

export type GetFriendStatusError = unknown;

export type UnfriendData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type UnfriendResponse = Success;

export type UnfriendError = unknown;

export type SearchGroupsData = {
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Query to search for, can be either Group Name or Group shortCode
         */
        query?: string;
    };
};

export type SearchGroupsResponse = Array<LimitedGroup>;

export type SearchGroupsError = unknown;

export type CreateGroupData = {
    body: CreateGroupRequest;
};

export type CreateGroupResponse = Group;

export type CreateGroupError = unknown;

export type GetGroupData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * Include roles for the Group object. Defaults to false.
         */
        includeRoles?: boolean;
    };
};

export type GetGroupResponse = Group;

export type GetGroupError = unknown;

export type UpdateGroupData = {
    body?: UpdateGroupRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type UpdateGroupResponse = Group;

export type UpdateGroupError = unknown;

export type DeleteGroupData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type DeleteGroupResponse = Success;

export type DeleteGroupError = unknown;

export type GetGroupAnnouncementsData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type GetGroupAnnouncementsResponse = GroupAnnouncement;

export type GetGroupAnnouncementsError = unknown;

export type CreateGroupAnnouncementData = {
    body: CreateGroupAnnouncementRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type CreateGroupAnnouncementResponse = GroupAnnouncement;

export type CreateGroupAnnouncementError = unknown;

export type DeleteGroupAnnouncementData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type DeleteGroupAnnouncementResponse = Success;

export type DeleteGroupAnnouncementError = unknown;

export type GetGroupAuditLogsData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The end date of the search range.
         */
        endDate?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The start date of the search range.
         */
        startDate?: string;
    };
};

export type GetGroupAuditLogsResponse = PaginatedGroupAuditLogEntryList;

export type GetGroupAuditLogsError = unknown;

export type GetGroupBansData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
};

export type GetGroupBansResponse = Array<GroupMember>;

export type GetGroupBansError = unknown;

export type BanGroupMemberData = {
    body: BanGroupMemberRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type BanGroupMemberResponse = GroupMember;

export type BanGroupMemberError = unknown;

export type UnbanGroupMemberData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type UnbanGroupMemberResponse = GroupMember;

export type UnbanGroupMemberError = unknown;

export type CreateGroupGalleryData = {
    body: CreateGroupGalleryRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type CreateGroupGalleryResponse = GroupGallery;

export type CreateGroupGalleryError = unknown;

export type GetGroupGalleryImagesData = {
    path: {
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * If specified, only returns images that have been approved or not approved.
         */
        approved?: boolean;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
};

export type GetGroupGalleryImagesResponse = Array<GroupGalleryImage>;

export type GetGroupGalleryImagesError = unknown;

export type UpdateGroupGalleryData = {
    body?: UpdateGroupGalleryRequest;
    path: {
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type UpdateGroupGalleryResponse = GroupGallery;

export type UpdateGroupGalleryError = unknown;

export type DeleteGroupGalleryData = {
    path: {
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type DeleteGroupGalleryResponse = Success;

export type DeleteGroupGalleryError = unknown;

export type AddGroupGalleryImageData = {
    body: AddGroupGalleryImageRequest;
    path: {
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type AddGroupGalleryImageResponse = GroupGalleryImage;

export type AddGroupGalleryImageError = unknown;

export type DeleteGroupGalleryImageData = {
    path: {
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
        /**
         * Must be a valid group gallery image ID.
         */
        groupGalleryImageId: string;
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type DeleteGroupGalleryImageResponse = Success;

export type DeleteGroupGalleryImageError = unknown;

export type GetGroupInstancesData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type GetGroupInstancesResponse = Array<GroupInstance>;

export type GetGroupInstancesError = unknown;

export type GetGroupInvitesData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
};

export type GetGroupInvitesResponse = Array<GroupMember>;

export type GetGroupInvitesError = unknown;

export type CreateGroupInviteData = {
    body: CreateGroupInviteRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type CreateGroupInviteResponse = unknown;

export type CreateGroupInviteError = unknown;

export type DeleteGroupInviteData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type DeleteGroupInviteResponse = unknown;

export type DeleteGroupInviteError = unknown;

export type JoinGroupData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type JoinGroupResponse = GroupMember;

export type JoinGroupError = unknown;

export type LeaveGroupData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type LeaveGroupResponse = unknown;

export type LeaveGroupError = unknown;

export type GetGroupMembersData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The sort order of Group Member results
         */
        sort?: GroupSearchSort;
    };
};

export type GetGroupMembersResponse = Array<GroupMember>;

export type GetGroupMembersError = unknown;

export type GetGroupMemberData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetGroupMemberResponse = GroupLimitedMember;

export type GetGroupMemberError = unknown;

export type UpdateGroupMemberData = {
    body?: UpdateGroupMemberRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type UpdateGroupMemberResponse = GroupLimitedMember;

export type UpdateGroupMemberError = unknown;

export type KickGroupMemberData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type KickGroupMemberResponse = unknown;

export type KickGroupMemberError = unknown;

export type AddGroupMemberRoleData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type AddGroupMemberRoleResponse = GroupRoleIDList;

export type AddGroupMemberRoleError = unknown;

export type RemoveGroupMemberRoleData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type RemoveGroupMemberRoleResponse = GroupRoleIDList;

export type RemoveGroupMemberRoleError = unknown;

export type GetGroupPermissionsData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type GetGroupPermissionsResponse = Array<GroupPermission>;

export type GetGroupPermissionsError = unknown;

export type GetGroupPostData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * See public posts only.
         */
        publicOnly?: boolean;
    };
};

export type GetGroupPostResponse = GroupPost;

export type GetGroupPostError = unknown;

export type AddGroupPostData = {
    body: CreateGroupPostRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type AddGroupPostResponse = GroupPost;

export type AddGroupPostError = unknown;

export type DeleteGroupPostData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
};

export type DeleteGroupPostResponse = Success;

export type DeleteGroupPostError = unknown;

export type UpdateGroupPostData = {
    body: CreateGroupPostRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
};

export type UpdateGroupPostResponse = GroupPost;

export type UpdateGroupPostError = unknown;

export type GetGroupRequestsData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * See blocked join requests
         */
        blocked?: boolean;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
};

export type GetGroupRequestsResponse = Array<GroupMember>;

export type GetGroupRequestsError = unknown;

export type CancelGroupRequestData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type CancelGroupRequestResponse = unknown;

export type CancelGroupRequestError = unknown;

export type RespondGroupJoinRequestData = {
    body: RespondGroupJoinRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type RespondGroupJoinRequestResponse = unknown;

export type RespondGroupJoinRequestError = unknown;

export type GetGroupRolesData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type GetGroupRolesResponse = Array<GroupRole>;

export type GetGroupRolesError = unknown;

export type CreateGroupRoleData = {
    body: CreateGroupRoleRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
};

export type CreateGroupRoleResponse = GroupRole;

export type CreateGroupRoleError = unknown;

export type UpdateGroupRoleData = {
    body?: UpdateGroupRoleRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
    };
};

export type UpdateGroupRoleResponse = Array<GroupRole>;

export type UpdateGroupRoleError = unknown;

export type DeleteGroupRoleData = {
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
    };
};

export type DeleteGroupRoleResponse = Array<GroupRole>;

export type DeleteGroupRoleError = unknown;

export type InviteUserData = {
    /**
     * Slot number of the Invite Message to use when inviting a user.
     */
    body: InviteRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type InviteUserResponse = SentNotification;

export type InviteUserError = unknown;

export type InviteMyselfToData = {
    path: {
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type InviteMyselfToResponse = SentNotification;

export type InviteMyselfToError = unknown;

export type RequestInviteData = {
    /**
     * Slot number of the Request Message to use when request an invite.
     */
    body?: RequestInviteRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type RequestInviteResponse = Notification;

export type RequestInviteError = unknown;

export type RespondInviteData = {
    /**
     * Slot number of the Response Message to use when responding to a user.
     */
    body: InviteResponse;
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
};

export type RespondInviteResponse = Notification;

export type RespondInviteError = unknown;

export type GetInviteMessagesData = {
    path: {
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetInviteMessagesResponse = Array<InviteMessage>;

export type GetInviteMessagesError = unknown;

export type GetInviteMessageData = {
    path: {
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
        /**
         * The message slot to fetch of a given message type.
         */
        slot: number;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetInviteMessageResponse = InviteMessage;

export type GetInviteMessageError = unknown;

export type UpdateInviteMessageData = {
    /**
     * Message of what to set the invite message to.
     */
    body?: UpdateInviteMessageRequest;
    path: {
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
        /**
         * The message slot to fetch of a given message type.
         */
        slot: number;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type UpdateInviteMessageResponse = Array<InviteMessage>;

export type UpdateInviteMessageError = unknown;

export type ResetInviteMessageData = {
    path: {
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
        /**
         * The message slot to fetch of a given message type.
         */
        slot: number;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type ResetInviteMessageResponse = Array<InviteMessage>;

export type ResetInviteMessageError = unknown;

export type CreateInstanceData = {
    body: CreateInstanceRequest;
};

export type CreateInstanceResponse = Instance;

export type CreateInstanceError = unknown;

export type GetInstanceData = {
    path: {
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type GetInstanceResponse = Instance;

export type GetInstanceError = unknown;

export type CloseInstanceData = {
    path: {
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: {
        /**
         * The time after which users won't be allowed to join the instances.
         * If omitted, the instance will be closed immediately.
         */
        closedAt?: string;
        /**
         * Whether to hard close the instance. Defaults to false.
         */
        hardClose?: boolean;
    };
};

export type CloseInstanceResponse = Instance;

export type CloseInstanceError = unknown;

export type GetShortNameData = {
    path: {
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type GetShortNameResponse = InstanceShortNameResponse;

export type GetShortNameError = unknown;

export type SendSelfInviteData = {
    path: {
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type SendSelfInviteResponse = Success;

export type SendSelfInviteError = unknown;

export type GetInstanceByShortNameData = {
    path: {
        /**
         * Must be a valid instance short name.
         */
        shortName: string;
    };
};

export type GetInstanceByShortNameResponse = Instance;

export type GetInstanceByShortNameError = unknown;

export type GetNotificationsData = {
    query?: {
        /**
         * Only return notifications sent after this Date. Ignored if type is `friendRequest`.
         */
        after?: string;
        /**
         * Whether to return hidden or non-hidden notifications. True only allowed on type `friendRequest`.
         */
        hidden?: boolean;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Return notifications sent by the user. Must be false or omitted.
         * @deprecated
         */
        sent?: boolean;
        /**
         * Only send notifications of this type (can use `all` for all). This parameter no longer does anything, and is deprecated.
         * @deprecated
         */
        type?: string;
    };
};

export type GetNotificationsResponse = Array<Notification>;

export type GetNotificationsError = unknown;

export type AcceptFriendRequestData = {
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
};

export type AcceptFriendRequestResponse = Success;

export type AcceptFriendRequestError = unknown;

export type MarkNotificationAsReadData = {
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
};

export type MarkNotificationAsReadResponse = Notification;

export type MarkNotificationAsReadError = unknown;

export type DeleteNotificationData = {
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
};

export type DeleteNotificationResponse = Notification;

export type DeleteNotificationError = unknown;

export type ClearNotificationsResponse = Success;

export type ClearNotificationsError = unknown;

export type GetAssignedPermissionsResponse = Array<Permission>;

export type GetAssignedPermissionsError = unknown;

export type GetPermissionData = {
    path: {
        /**
         * Must be a valid permission ID.
         */
        permissionId: string;
    };
};

export type GetPermissionResponse = Permission;

export type GetPermissionError = unknown;

export type GetPlayerModerationsData = {
    query?: {
        /**
         * Must be valid UserID.
         */
        targetUserId?: string;
        /**
         * Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
         */
        type?: string;
    };
};

export type GetPlayerModerationsResponse = Array<PlayerModeration>;

export type GetPlayerModerationsError = unknown;

export type ModerateUserData = {
    body: ModerateUserRequest;
};

export type ModerateUserResponse = PlayerModeration;

export type ModerateUserError = unknown;

export type ClearAllPlayerModerationsResponse = Success;

export type ClearAllPlayerModerationsError = unknown;

export type GetPlayerModerationData = {
    path: {
        /**
         * Must be a valid `pmod_` ID.
         */
        playerModerationId: string;
    };
};

export type GetPlayerModerationResponse = PlayerModeration;

export type GetPlayerModerationError = unknown;

export type DeletePlayerModerationData = {
    path: {
        /**
         * Must be a valid `pmod_` ID.
         */
        playerModerationId: string;
    };
};

export type DeletePlayerModerationResponse = Success;

export type DeletePlayerModerationError = unknown;

export type UnmoderateUserData = {
    body: ModerateUserRequest;
};

export type UnmoderateUserResponse = Success;

export type UnmoderateUserError = unknown;

export type GetConfigResponse = APIConfig;

export type GetConfigError = unknown;

export type GetInfoPushData = {
    query?: {
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        include?: string;
        /**
         * Tags to include (comma-separated). All of the tags needs to be present.
         */
        require?: string;
    };
};

export type GetInfoPushResponse = Array<InfoPush>;

export type GetInfoPushError = unknown;

export type GetCssData = {
    query?: {
        /**
         * Specifies which git branch the site should load frontend source code from.
         */
        branch?: string;
        /**
         * Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management.
         */
        variant?: 'public' | 'internal';
    };
};

export type GetCssResponse = string;

export type GetCssError = unknown;

export type GetJavaScriptData = {
    query?: {
        /**
         * Specifies which git branch the site should load frontend source code from.
         */
        branch?: string;
        /**
         * Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management.
         */
        variant?: 'public' | 'internal';
    };
};

export type GetJavaScriptResponse = string;

export type GetJavaScriptError = unknown;

export type GetHealthResponse = APIHealth;

export type GetHealthError = unknown;

export type GetCurrentOnlineUsersResponse = number;

export type GetCurrentOnlineUsersError = unknown;

export type GetSystemTimeResponse = string;

export type GetSystemTimeError = unknown;

export type SearchUsersData = {
    query?: {
        /**
         * Active user by developer type, none for normal users and internal for moderators
         */
        developerType?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Searches by `displayName`. Will return empty array if search query is empty or missing.
         */
        search?: string;
    };
};

export type SearchUsersResponse = Array<LimitedUser>;

export type SearchUsersError = unknown;

export type GetUserByNameData = {
    path: {
        /**
         * Username of the user
         */
        username: string;
    };
};

export type GetUserByNameResponse = User;

export type GetUserByNameError = unknown;

export type GetUserData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetUserResponse = User;

export type GetUserError = unknown;

export type UpdateUserData = {
    body?: UpdateUserRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type UpdateUserResponse = CurrentUser;

export type UpdateUserError = unknown;

export type GetUserGroupsData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetUserGroupsResponse = Array<LimitedUserGroups>;

export type GetUserGroupsError = unknown;

export type GetUserGroupRequestsData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetUserGroupRequestsResponse = Array<Group>;

export type GetUserGroupRequestsError = unknown;

export type GetUserRepresentedGroupData = {
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
};

export type GetUserRepresentedGroupResponse = representedGroup;

export type GetUserRepresentedGroupError = unknown;

export type SearchWorldsData = {
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Set to `me` for searching own worlds.
         */
        user?: 'me';
        /**
         * Filter by UserID.
         */
        userId?: string;
    };
};

export type SearchWorldsResponse = Array<LimitedWorld>;

export type SearchWorldsError = unknown;

export type CreateWorldData = {
    body?: CreateWorldRequest;
};

export type CreateWorldResponse = World;

export type CreateWorldError = unknown;

export type GetActiveWorldsData = {
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
    };
};

export type GetActiveWorldsResponse = Array<LimitedWorld>;

export type GetActiveWorldsError = unknown;

export type GetFavoritedWorldsData = {
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Target user to see information on, admin-only.
         */
        userId?: string;
    };
};

export type GetFavoritedWorldsResponse = Array<LimitedWorld>;

export type GetFavoritedWorldsError = unknown;

export type GetRecentWorldsData = {
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Target user to see information on, admin-only.
         */
        userId?: string;
    };
};

export type GetRecentWorldsResponse = Array<LimitedWorld>;

export type GetRecentWorldsError = unknown;

export type GetWorldData = {
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type GetWorldResponse = World;

export type GetWorldError = unknown;

export type UpdateWorldData = {
    body?: UpdateWorldRequest;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type UpdateWorldResponse = World;

export type UpdateWorldError = unknown;

export type DeleteWorldData = {
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type DeleteWorldResponse = unknown;

export type DeleteWorldError = unknown;

export type GetWorldMetadataData = {
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type GetWorldMetadataResponse = WorldMetadata;

export type GetWorldMetadataError = unknown;

export type GetWorldPublishStatusData = {
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type GetWorldPublishStatusResponse = WorldPublishStatus;

export type GetWorldPublishStatusError = unknown;

export type PublishWorldData = {
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type PublishWorldResponse = unknown;

export type PublishWorldError = unknown;

export type UnpublishWorldData = {
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type UnpublishWorldResponse = unknown;

export type UnpublishWorldError = unknown;

export type GetWorldInstanceData = {
    path: {
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
};

export type GetWorldInstanceResponse = Instance;

export type GetWorldInstanceError = unknown;

export type $OpenApiTs = {
    '/auth/exists': {
        get: {
            req: CheckUserExistsData;
            res: {
                /**
                 * Returns a response if a user exists or not.
                 */
                '200': UserExists;
                /**
                 * Error response when missing at least 1 of the required parameters.
                 */
                '400': Error;
            };
        };
    };
    '/auth/user': {
        get: {
            res: {
                /**
                 * OK
                 */
                '200': CurrentUser;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/twofactorauth/totp/verify': {
        post: {
            req: Verify2FaData;
            res: {
                /**
                 * OK
                 */
                '200': Verify2FAResult;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/twofactorauth/otp/verify': {
        post: {
            req: VerifyRecoveryCodeData;
            res: {
                /**
                 * OK
                 */
                '200': Verify2FAResult;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/twofactorauth/emailotp/verify': {
        post: {
            req: Verify2FaEmailCodeData;
            res: {
                /**
                 * OK
                 */
                '200': Verify2FAEmailCodeResult;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth': {
        get: {
            res: {
                /**
                 * Returns wether a provided auth token is valid or not.
                 */
                '200': VerifyAuthTokenResult;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/logout': {
        put: {
            res: {
                /**
                 * OK
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/users/{userId}/delete': {
        put: {
            req: DeleteUserData;
            res: {
                /**
                 * OK
                 */
                '200': CurrentUser;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/users/{userId}/avatar': {
        get: {
            req: GetOwnAvatarData;
            res: {
                /**
                 * Returns a single Avatar object.
                 */
                '200': Avatar;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to see another users current avatar without sufficient admin permissions.
                 */
                '403': Error;
            };
        };
    };
    '/avatars': {
        get: {
            req: SearchAvatarsData;
            res: {
                /**
                 * Returns a list of Avatar objects.
                 */
                '200': Array<Avatar>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        post: {
            req: CreateAvatarData;
            res: {
                /**
                 * Returns a single Avatar object.
                 */
                '200': Avatar;
                /**
                 * Error response when set featured to true without being an admin.
                 */
                '401': Error;
            };
        };
    };
    '/avatars/{avatarId}': {
        get: {
            req: GetAvatarData;
            res: {
                /**
                 * Returns a single Avatar object.
                 */
                '200': Avatar;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent avatar.
                 */
                '404': Error;
            };
        };
        put: {
            req: UpdateAvatarData;
            res: {
                /**
                 * Returns a single Avatar object.
                 */
                '200': Avatar;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent avatar.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeleteAvatarData;
            res: {
                /**
                 * Returns a single Avatar object.
                 */
                '200': Avatar;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent avatar.
                 */
                '404': Error;
            };
        };
    };
    '/avatars/{avatarId}/select': {
        put: {
            req: SelectAvatarData;
            res: {
                /**
                 * Returns a single CurrentUser object.
                 */
                '200': CurrentUser;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent avatar.
                 */
                '404': Error;
            };
        };
    };
    '/avatars/{avatarId}/selectFallback': {
        put: {
            req: SelectFallbackAvatarData;
            res: {
                /**
                 * Returns a single CurrentUser object.
                 */
                '200': CurrentUser;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to select a fallback avatar that is missing the fallback tag.
                 */
                '403': Error;
                /**
                 * Error response when trying to show information about a non-existent avatar.
                 */
                '404': Error;
            };
        };
    };
    '/avatars/favorites': {
        get: {
            req: GetFavoritedAvatarsData;
            res: {
                /**
                 * Returns a list of Avatar objects.
                 */
                '200': Array<Avatar>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to see favourited avatars of another user without sufficient admin permissions.
                 */
                '403': Error;
            };
        };
    };
    '/Steam/transactions': {
        get: {
            res: {
                /**
                 * Returns a list of Transaction objects.
                 */
                '200': Array<Transaction>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/Steam/transactions/{transactionId}': {
        get: {
            req: GetSteamTransactionData;
            res: {
                /**
                 * Returns a single Transaction object.
                 */
                '200': Transaction;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/user/subscription': {
        get: {
            res: {
                /**
                 * Returns a list of UserSubscription objects.
                 */
                '200': Array<UserSubscription>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/subscriptions': {
        get: {
            res: {
                /**
                 * Returns a list of Subscription objects.
                 */
                '200': Array<Subscription>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/licenseGroups/{licenseGroupId}': {
        get: {
            req: GetLicenseGroupData;
            res: {
                /**
                 * Returns a single LicenseGroup object.
                 */
                '200': LicenseGroup;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/favorites': {
        get: {
            req: GetFavoritesData;
            res: {
                /**
                 * Returns a list of Favorite objects.
                 */
                '200': Array<Favorite>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        post: {
            req: AddFavoriteData;
            res: {
                /**
                 * Returns a single Favorite object.
                 */
                '200': Favorite;
                /**
                 * Error response when trying favorite someone or something when already having it/them favorited.
                 */
                '400': Error;
                /**
                 * Error response when trying favorite someone whom you are not friends with.
                 */
                '403': Error;
            };
        };
    };
    '/favorites/{favoriteId}': {
        get: {
            req: GetFavoriteData;
            res: {
                /**
                 * Returns a single Favorite object.
                 */
                '200': Favorite;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent favorite.
                 */
                '404': Error;
            };
        };
        delete: {
            req: RemoveFavoriteData;
            res: {
                /**
                 * Success response after removing a favorite.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent favorite.
                 */
                '404': Error;
            };
        };
    };
    '/favorite/groups': {
        get: {
            req: GetFavoriteGroupsData;
            res: {
                /**
                 * Returns a list of FavoriteGroup objects.
                 */
                '200': Array<FavoriteGroup>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}': {
        get: {
            req: GetFavoriteGroupData;
            res: {
                /**
                 * Returns a single FavoriteGroup object.
                 */
                '200': FavoriteGroup;
            };
        };
        put: {
            req: UpdateFavoriteGroupData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
            };
        };
        delete: {
            req: ClearFavoriteGroupData;
            res: {
                /**
                 * Success response after clearing a favorite group.
                 */
                '200': Success;
            };
        };
    };
    '/files': {
        get: {
            req: GetFilesData;
            res: {
                /**
                 * Returns a list of File objects.
                 */
                '200': Array<File>;
            };
        };
    };
    '/file': {
        post: {
            req: CreateFileData;
            res: {
                /**
                 * Returns a single File object.
                 */
                '200': File;
            };
        };
    };
    '/file/{fileId}': {
        get: {
            req: GetFileData;
            res: {
                /**
                 * Returns a single File object.
                 */
                '200': File;
                /**
                 * Error response when trying to show information about a non-existent file.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeleteFileData;
            res: {
                /**
                 * Successful response after deleting a File.
                 */
                '200': Success;
                /**
                 * Error response when trying to delete a non-existent file.
                 */
                '404': Error;
            };
        };
        post: {
            req: CreateFileVersionData;
            res: {
                /**
                 * Returns a single File object.
                 */
                '200': File;
            };
        };
    };
    '/file/{fileId}/{versionId}': {
        get: {
            req: DownloadFileVersionData;
            res: {
                /**
                 * Raw file
                 */
                '200': unknown;
            };
        };
        delete: {
            req: DeleteFileVersionData;
            res: {
                /**
                 * Returns a single File object.
                 */
                '200': File;
                /**
                 * Error response when trying to delete the initial version of a file. Delete the main File object instead.
                 */
                '400': Error;
                /**
                 * Error response when trying to delete any version of a file that is not hte last one.
                 */
                '500': Error;
            };
        };
    };
    '/file/{fileId}/{versionId}/{fileType}/finish': {
        put: {
            req: FinishFileDataUploadData;
            res: {
                /**
                 * Returns a single File object.
                 */
                '200': File;
            };
        };
    };
    '/file/{fileId}/{versionId}/{fileType}/start': {
        put: {
            req: StartFileDataUploadData;
            res: {
                /**
                 * See [https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html](AWS REST docs - PUT Object)
                 */
                '200': FileUploadURL;
                /**
                 * Error response when trying to start an upload against a FileVersion that is already marked as  `complete`.
                 */
                '400': Error;
            };
        };
    };
    '/file/{fileId}/{versionId}/{fileType}/status': {
        get: {
            req: GetFileDataUploadStatusData;
            res: {
                /**
                 * Current FileVersion upload status. Contains the uploadId needed for uploading, as well as the already uploaded parts.
                 */
                '200': FileVersionUploadStatus;
            };
        };
    };
    '/auth/user/friends': {
        get: {
            req: GetFriendsData;
            res: {
                /**
                 * Returns a list of LimitedUser objects.
                 */
                '200': Array<LimitedUser>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/user/{userId}/friendRequest': {
        post: {
            req: FriendData;
            res: {
                /**
                 * Returns a single Notifcation object.
                 */
                '200': Notification;
                /**
                 * Bad request error response when sending a friend request
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to send a friend request to a user which doesn't exist.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeleteFriendRequestData;
            res: {
                /**
                 * Successful response after cancelling a friend request.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to delete a non-existent friend-request.
                 */
                '404': Error;
            };
        };
    };
    '/user/{userId}/friendStatus': {
        get: {
            req: GetFriendStatusData;
            res: {
                /**
                 * Returns a users Friend Status.
                 */
                '200': FriendStatus;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/user/friends/{userId}': {
        delete: {
            req: UnfriendData;
            res: {
                /**
                 * Successful response after unfriending a user.
                 */
                '200': Success;
                /**
                 * Error response when trying to unfriend someone who is not a friend.
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/groups': {
        get: {
            req: SearchGroupsData;
            res: {
                /**
                 * Returns a list of LimitedGroup objects.
                 */
                '200': Array<LimitedGroup>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        post: {
            req: CreateGroupData;
            res: {
                /**
                 * Returns a single Group object.
                 */
                '200': Group;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/groups/{groupId}': {
        get: {
            req: GetGroupData;
            res: {
                /**
                 * Returns a single Group object.
                 */
                '200': Group;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        put: {
            req: UpdateGroupData;
            res: {
                /**
                 * Returns a single Group object.
                 */
                '200': Group;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeleteGroupData;
            res: {
                /**
                 * Successful response after deleting a Group.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/announcement': {
        get: {
            req: GetGroupAnnouncementsData;
            res: {
                /**
                 * Returns a single GroupAnnouncement object.
                 */
                '200': GroupAnnouncement;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        post: {
            req: CreateGroupAnnouncementData;
            res: {
                /**
                 * Returns a single GroupAnnouncement object.
                 */
                '200': GroupAnnouncement;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeleteGroupAnnouncementData;
            res: {
                /**
                 * Successful response after deleting/clearing the group announcement.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/auditLogs': {
        get: {
            req: GetGroupAuditLogsData;
            res: {
                /**
                 * Returns a list of GroupAudit objects, wrapped in new pagination format.
                 */
                '200': PaginatedGroupAuditLogEntryList;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/bans': {
        get: {
            req: GetGroupBansData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': Array<GroupMember>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        post: {
            req: BanGroupMemberData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': GroupMember;
                /**
                 * Bad request error response when banning a user
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/bans/{userId}': {
        delete: {
            req: UnbanGroupMemberData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': GroupMember;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/galleries': {
        post: {
            req: CreateGroupGalleryData;
            res: {
                /**
                 * Returns a single GroupGallery object.
                 */
                '200': GroupGallery;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/galleries/{groupGalleryId}': {
        get: {
            req: GetGroupGalleryImagesData;
            res: {
                /**
                 * Returns a list of GroupGalleryImage objects.
                 */
                '200': Array<GroupGalleryImage>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        put: {
            req: UpdateGroupGalleryData;
            res: {
                /**
                 * Returns a single GroupGallery object.
                 */
                '200': GroupGallery;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeleteGroupGalleryData;
            res: {
                /**
                 * Successful response after deleting a group gallery.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/galleries/{groupGalleryId}/images': {
        post: {
            req: AddGroupGalleryImageData;
            res: {
                /**
                 * Returns a single GroupGalleryImage object.
                 */
                '200': GroupGalleryImage;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}': {
        delete: {
            req: DeleteGroupGalleryImageData;
            res: {
                /**
                 * Successful response after deleting a group gallery image.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to delete a submission to a group's gallery when the user does not have permission to do so.
                 */
                '403': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/instances': {
        get: {
            req: GetGroupInstancesData;
            res: {
                /**
                 * Returns a list of GroupInstance objects.
                 */
                '200': Array<GroupInstance>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/invites': {
        get: {
            req: GetGroupInvitesData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': Array<GroupMember>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a group you are not member of.
                 */
                '403': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        post: {
            req: CreateGroupInviteData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * Bad request error response when creating a group invite.
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Forbidden error response when creating a group invite.
                 */
                '403': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/invites/{userId}': {
        delete: {
            req: DeleteGroupInviteData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * Bad request error response when deleting a group invite
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/groups/{groupId}/join': {
        post: {
            req: JoinGroupData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': GroupMember;
                /**
                 * Error response when trying to join a group that the user is already a member of.
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/leave': {
        post: {
            req: LeaveGroupData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * Error response when trying to perform operations on a group you are not member of.
                 */
                '403': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/members': {
        get: {
            req: GetGroupMembersData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': Array<GroupMember>;
                /**
                 * Error response when trying to search list of users with an invalid request.
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/members/{userId}': {
        get: {
            req: GetGroupMemberData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': GroupLimitedMember;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        put: {
            req: UpdateGroupMemberData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': GroupLimitedMember;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        delete: {
            req: KickGroupMemberData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a group you are not member of.
                 */
                '403': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/members/{userId}/roles/{groupRoleId}': {
        put: {
            req: AddGroupMemberRoleData;
            res: {
                /**
                 * Returns a list of GroupRoleID objects.
                 */
                '200': GroupRoleIDList;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        delete: {
            req: RemoveGroupMemberRoleData;
            res: {
                /**
                 * Returns a list of GroupRoleID objects.
                 */
                '200': GroupRoleIDList;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/permissions': {
        get: {
            req: GetGroupPermissionsData;
            res: {
                /**
                 * Returns a list of GroupPermission objects.
                 */
                '200': Array<GroupPermission>;
                /**
                 * Error response when trying to search list of users with an invalid request.
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/posts': {
        get: {
            req: GetGroupPostData;
            res: {
                /**
                 * Returns a GroupPost object.
                 */
                '200': GroupPost;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        post: {
            req: AddGroupPostData;
            res: {
                /**
                 * Returns a GroupPost object.
                 */
                '200': GroupPost;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/groups/{groupId}/posts/{notificationId}': {
        delete: {
            req: DeleteGroupPostData;
            res: {
                /**
                 * Response after deleting a group post.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Response after deleting a group post.
                 */
                '404': Success;
            };
        };
        put: {
            req: UpdateGroupPostData;
            res: {
                /**
                 * Returns a GroupPost object.
                 */
                '200': GroupPost;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Response after deleting a group post.
                 */
                '404': Success;
            };
        };
    };
    '/groups/{groupId}/requests': {
        get: {
            req: GetGroupRequestsData;
            res: {
                /**
                 * Returns a list of GroupMember objects.
                 */
                '200': Array<GroupMember>;
                /**
                 * Bad request error response when responding to a group join request
                 */
                '400': Error;
                /**
                 * Error response when trying to perform operations on a group you are not member of.
                 */
                '403': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        delete: {
            req: CancelGroupRequestData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * You can't cancel a join request if you didn't request to join․
                 */
                '400': unknown;
                /**
                 * Error response when trying to perform operations on a group you are not member of.
                 */
                '403': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/requests/{userId}': {
        put: {
            req: RespondGroupJoinRequestData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/roles': {
        get: {
            req: GetGroupRolesData;
            res: {
                /**
                 * Returns a list of GroupRole objects.
                 */
                '200': Array<GroupRole>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
        post: {
            req: CreateGroupRoleData;
            res: {
                /**
                 * Returns a single GroupRole object.
                 */
                '200': GroupRole;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a non-existing group.
                 */
                '404': Error;
            };
        };
    };
    '/groups/{groupId}/roles/{groupRoleId}': {
        put: {
            req: UpdateGroupRoleData;
            res: {
                /**
                 * Returns a list of GroupRole objects.
                 */
                '200': Array<GroupRole>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        delete: {
            req: DeleteGroupRoleData;
            res: {
                /**
                 * Returns a list of GroupRole objects.
                 */
                '200': Array<GroupRole>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to perform operations on a group you are not member of.
                 */
                '404': Error;
            };
        };
    };
    '/invite/{userId}': {
        post: {
            req: InviteUserData;
            res: {
                /**
                 * Returns a single SentNotifcation object.
                 */
                '200': SentNotification;
                /**
                 * Error response when trying to invite someome whom you are not friends with.
                 */
                '403': Error;
            };
        };
    };
    '/invite/myself/to/{worldId}:{instanceId}': {
        post: {
            req: InviteMyselfToData;
            res: {
                /**
                 * Returns a single SentNotifcation object.
                 */
                '200': SentNotification;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response due to non existant instance
                 */
                '404': Error;
            };
        };
    };
    '/requestInvite/{userId}': {
        post: {
            req: RequestInviteData;
            res: {
                /**
                 * Returns a single Notifcation object.
                 */
                '200': Notification;
                /**
                 * Error response when trying to invite someome whom you are not friends with.
                 */
                '403': Error;
            };
        };
    };
    '/invite/{notificationId}/response': {
        post: {
            req: RespondInviteData;
            res: {
                /**
                 * Returns a single Notifcation object.
                 */
                '200': Notification;
                /**
                 * Error response when trying to respond to an invite and something went wrong.
                 */
                '400': Error;
            };
        };
    };
    '/message/{userId}/{messageType}': {
        get: {
            req: GetInviteMessagesData;
            res: {
                /**
                 * Returns a list of InviteMessage objects.
                 */
                '200': Array<InviteMessage>;
                /**
                 * Error response when trying to update an Invite Message with an invalid slot number.
                 */
                '400': Error;
                /**
                 * Error response due to missing authorization to perform that action.
                 */
                '401': Error;
            };
        };
    };
    '/message/{userId}/{messageType}/{slot}': {
        get: {
            req: GetInviteMessageData;
            res: {
                /**
                 * Returns a single InviteMessage object.
                 */
                '200': InviteMessage;
                /**
                 * Error response when trying to get an Invite Message with a negative slot number.
                 */
                '400': Error;
                /**
                 * Error response due to missing authorization to perform that action.
                 */
                '401': Error;
                /**
                 * Error response when trying to get an Invite Message with a too high slot number.
                 */
                '404': Error;
            };
        };
        put: {
            req: UpdateInviteMessageData;
            res: {
                /**
                 * Returns a list of InviteMessage objects.
                 */
                '200': Array<InviteMessage>;
                /**
                 * Error response when trying to update an Invite Message with an invalid slot number.
                 */
                '400': Error;
                /**
                 * Error response due to missing authorization to perform that action.
                 */
                '401': Error;
                /**
                 * Error response when trying to update an Invite Message before the cooldown has expired.
                 */
                '429': Error;
            };
        };
        delete: {
            req: ResetInviteMessageData;
            res: {
                /**
                 * Returns a list of InviteMessage objects.
                 */
                '200': Array<InviteMessage>;
                /**
                 * Error response when trying to update an Invite Message with an invalid slot number.
                 */
                '400': Error;
                /**
                 * Error response due to missing authorization to perform that action.
                 */
                '401': Error;
                /**
                 * Error response when trying to reset an Invite Message whos slot doesn't exist.
                 */
                '404': Error;
                /**
                 * Error response when trying to update an Invite Message before the cooldown has expired.
                 */
                '429': Error;
            };
        };
    };
    '/instances': {
        post: {
            req: CreateInstanceData;
            res: {
                /**
                 * Returns a single Instance object.
                 */
                '200': Instance;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/instances/{worldId}:{instanceId}': {
        get: {
            req: GetInstanceData;
            res: {
                /**
                 * Returns a single Instance object.
                 */
                '200': Instance;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        delete: {
            req: CloseInstanceData;
            res: {
                /**
                 * Returns a single Instance object.
                 */
                '200': Instance;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response due to not being allowed to close an instance
                 */
                '403': Error;
                /**
                 * Error response due to non existant instance
                 */
                '404': Error;
            };
        };
    };
    '/instances/{worldId}:{instanceId}/shortName': {
        get: {
            req: GetShortNameData;
            res: {
                /**
                 * Returns an instance secureName and/or shortName.
                 */
                '200': InstanceShortNameResponse;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/instances/{worldId}:{instanceId}/invite': {
        post: {
            req: SendSelfInviteData;
            res: {
                /**
                 * Success response after sending an invite to yourself to the instance.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/instances/s/{shortName}': {
        get: {
            req: GetInstanceByShortNameData;
            res: {
                /**
                 * Returns a single Instance object.
                 */
                '200': Instance;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response due to non existant instance
                 */
                '404': Error;
            };
        };
    };
    '/auth/user/notifications': {
        get: {
            req: GetNotificationsData;
            res: {
                /**
                 * Returns a list of Notifcation objects.
                 */
                '200': Array<Notification>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/user/notifications/{notificationId}/accept': {
        put: {
            req: AcceptFriendRequestData;
            res: {
                /**
                 * Successful response after friending a user.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to accept a non-existent friend request.
                 */
                '404': Error;
            };
        };
    };
    '/auth/user/notifications/{notificationId}/see': {
        put: {
            req: MarkNotificationAsReadData;
            res: {
                /**
                 * Returns a single Notifcation object.
                 */
                '200': Notification;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/user/notifications/{notificationId}/hide': {
        put: {
            req: DeleteNotificationData;
            res: {
                /**
                 * Returns a single Notifcation object.
                 */
                '200': Notification;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/user/notifications/clear': {
        put: {
            res: {
                /**
                 * Successful response after clearing all notifications.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/permissions': {
        get: {
            res: {
                /**
                 * Returns a list of Permission objects.
                 */
                '200': Array<Permission>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/permissions/{permissionId}': {
        get: {
            req: GetPermissionData;
            res: {
                /**
                 * Returns a single Permission object.
                 */
                '200': Permission;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/user/playermoderations': {
        get: {
            req: GetPlayerModerationsData;
            res: {
                /**
                 * Returns a list of PlayerModeration objects.
                 */
                '200': Array<PlayerModeration>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        post: {
            req: ModerateUserData;
            res: {
                /**
                 * Returns a single PlayerModeration object.
                 */
                '200': PlayerModeration;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        delete: {
            res: {
                /**
                 * Success response after e.g. clearing all player moderations.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/auth/user/playermoderations/{playerModerationId}': {
        get: {
            req: GetPlayerModerationData;
            res: {
                /**
                 * Returns a single PlayerModeration object.
                 */
                '200': PlayerModeration;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent player moderation.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeletePlayerModerationData;
            res: {
                /**
                 * Success response after removing a PlayerModeration by ID.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to delete someone else's player moderation.
                 */
                '403': Error;
            };
        };
    };
    '/auth/user/unplayermoderate': {
        put: {
            req: UnmoderateUserData;
            res: {
                /**
                 * Success response after unmoderating a player moderation.
                 */
                '200': Success;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/config': {
        get: {
            res: {
                /**
                 * Returns the API's config.
                 */
                '200': APIConfig;
            };
        };
    };
    '/infoPush': {
        get: {
            req: GetInfoPushData;
            res: {
                /**
                 * Returns a list of InfoPush objects.
                 */
                '200': Array<InfoPush>;
            };
        };
    };
    '/css/app.css': {
        get: {
            req: GetCssData;
            res: {
                /**
                 * **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively.
                 */
                '200': string;
                /**
                 * Error response when trying to download non-public and non-main JavaScript or CSS without Admin Credentials.
                 */
                '400': Error;
            };
        };
    };
    '/js/app.js': {
        get: {
            req: GetJavaScriptData;
            res: {
                /**
                 * **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively.
                 */
                '200': string;
                /**
                 * Error response when trying to download non-public and non-main JavaScript or CSS without Admin Credentials.
                 */
                '400': Error;
            };
        };
    };
    '/health': {
        get: {
            res: {
                /**
                 * Returns the API's health.
                 */
                '200': APIHealth;
            };
        };
    };
    '/visits': {
        get: {
            res: {
                /**
                 * OK
                 */
                '200': number;
            };
        };
    };
    '/time': {
        get: {
            res: {
                /**
                 * OK
                 */
                '200': string;
            };
        };
    };
    '/users': {
        get: {
            req: SearchUsersData;
            res: {
                /**
                 * Returns a list of LimitedUser objects.
                 */
                '200': Array<LimitedUser>;
                /**
                 * Error response when trying to search list of users with an invalid request.
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/users/{username}/name': {
        get: {
            req: GetUserByNameData;
            res: {
                /**
                 * Returns a single User object.
                 */
                '200': User;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/users/{userId}': {
        get: {
            req: GetUserData;
            res: {
                /**
                 * Returns a single User object.
                 */
                '200': User;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        put: {
            req: UpdateUserData;
            res: {
                /**
                 * Returns a single CurrentUser object.
                 */
                '200': CurrentUser;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/users/{userId}/groups': {
        get: {
            req: GetUserGroupsData;
            res: {
                /**
                 * Returns a list of LimitedUserGroups objects.
                 */
                '200': Array<LimitedUserGroups>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/users/{userId}/groups/requested': {
        get: {
            req: GetUserGroupRequestsData;
            res: {
                /**
                 * Returns a list of Group objects.
                 */
                '200': Array<Group>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/users/{userId}/groups/represented': {
        get: {
            req: GetUserRepresentedGroupData;
            res: {
                /**
                 * OK
                 */
                '200': representedGroup;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/worlds': {
        get: {
            req: SearchWorldsData;
            res: {
                /**
                 * Returns a list of LimitedWorld objects.
                 */
                '200': Array<LimitedWorld>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
        post: {
            req: CreateWorldData;
            res: {
                /**
                 * Returns a single World object.
                 */
                '200': World;
                /**
                 * Error response when trying create a world without having the neccesary Trust rank yet.
                 */
                '400': Error;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/worlds/active': {
        get: {
            req: GetActiveWorldsData;
            res: {
                /**
                 * Returns a list of LimitedWorld objects.
                 */
                '200': Array<LimitedWorld>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
    '/worlds/favorites': {
        get: {
            req: GetFavoritedWorldsData;
            res: {
                /**
                 * Returns a list of LimitedWorld objects.
                 */
                '200': Array<LimitedWorld>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to see favourited worlds of another user without sufficient admin permissions.
                 */
                '403': Error;
            };
        };
    };
    '/worlds/recent': {
        get: {
            req: GetRecentWorldsData;
            res: {
                /**
                 * Returns a list of LimitedWorld objects.
                 */
                '200': Array<LimitedWorld>;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to see recently visited worlds of another user without sufficient admin permissions.
                 */
                '403': Error;
            };
        };
    };
    '/worlds/{worldId}': {
        get: {
            req: GetWorldData;
            res: {
                /**
                 * Returns a single World object.
                 */
                '200': World;
                /**
                 * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
                 */
                '404': Error;
            };
        };
        put: {
            req: UpdateWorldData;
            res: {
                /**
                 * Returns a single World object.
                 */
                '200': World;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
                 */
                '404': Error;
            };
        };
        delete: {
            req: DeleteWorldData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
                 */
                '404': Error;
            };
        };
    };
    '/worlds/{worldId}/metadata': {
        get: {
            req: GetWorldMetadataData;
            res: {
                /**
                 * OK
                 */
                '200': WorldMetadata;
                /**
                 * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
                 */
                '404': Error;
            };
        };
    };
    '/worlds/{worldId}/publish': {
        get: {
            req: GetWorldPublishStatusData;
            res: {
                /**
                 * Returns a single WorldPublishStatus object.
                 */
                '200': WorldPublishStatus;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
                 */
                '404': Error;
            };
        };
        put: {
            req: PublishWorldData;
            res: {
                /**
                 * TODO
                 */
                '200': unknown;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
                 */
                '404': Error;
            };
        };
        delete: {
            req: UnpublishWorldData;
            res: {
                /**
                 * OK
                 */
                '200': unknown;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
                /**
                 * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
                 */
                '404': Error;
            };
        };
    };
    '/worlds/{worldId}/{instanceId}': {
        get: {
            req: GetWorldInstanceData;
            res: {
                /**
                 * Returns a single Instance object.
                 */
                '200': Instance;
                /**
                 * Error response due to missing auth cookie.
                 */
                '401': Error;
            };
        };
    };
};